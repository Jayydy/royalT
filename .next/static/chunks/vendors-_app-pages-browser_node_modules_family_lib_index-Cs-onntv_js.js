"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-_app-pages-browser_node_modules_family_lib_index-Cs-onntv_js"],{

/***/ "(app-pages-browser)/./node_modules/family/lib/index-Cs-onntv.js":
/*!***************************************************!*\
  !*** ./node_modules/family/lib/index-Cs-onntv.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ index$1)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function (e) {\n\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar postRobot$1 = {exports: {}};\n\nvar postRobot = {exports: {}};\n\n(function (module, exports) {\n\t!function(root, factory) {\n\t    module.exports = factory() ;\n\t}(\"undefined\" != typeof self ? self : commonjsGlobal, (function() {\n\t    return function(modules) {\n\t        var installedModules = {};\n\t        function __nested_webpack_require_1042__(moduleId) {\n\t            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n\t            var module = installedModules[moduleId] = {\n\t                i: moduleId,\n\t                l: false,\n\t                exports: {}\n\t            };\n\t            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1042__);\n\t            module.l = true;\n\t            return module.exports;\n\t        }\n\t        __nested_webpack_require_1042__.m = modules;\n\t        __nested_webpack_require_1042__.c = installedModules;\n\t        __nested_webpack_require_1042__.d = function(exports, name, getter) {\n\t            __nested_webpack_require_1042__.o(exports, name) || Object.defineProperty(exports, name, {\n\t                enumerable: true,\n\t                get: getter\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.r = function(exports) {\n\t            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n\t                value: \"Module\"\n\t            });\n\t            Object.defineProperty(exports, \"__esModule\", {\n\t                value: true\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.t = function(value, mode) {\n\t            1 & mode && (value = __nested_webpack_require_1042__(value));\n\t            if (8 & mode) return value;\n\t            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n\t            var ns = Object.create(null);\n\t            __nested_webpack_require_1042__.r(ns);\n\t            Object.defineProperty(ns, \"default\", {\n\t                enumerable: true,\n\t                value: value\n\t            });\n\t            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_1042__.d(ns, key, function(key) {\n\t                return value[key];\n\t            }.bind(null, key));\n\t            return ns;\n\t        };\n\t        __nested_webpack_require_1042__.n = function(module) {\n\t            var getter = module && module.__esModule ? function() {\n\t                return module.default;\n\t            } : function() {\n\t                return module;\n\t            };\n\t            __nested_webpack_require_1042__.d(getter, \"a\", getter);\n\t            return getter;\n\t        };\n\t        __nested_webpack_require_1042__.o = function(object, property) {\n\t            return {}.hasOwnProperty.call(object, property);\n\t        };\n\t        __nested_webpack_require_1042__.p = \"\";\n\t        return __nested_webpack_require_1042__(__nested_webpack_require_1042__.s = 0);\n\t    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_3517__) {\n\t        __nested_webpack_require_3517__.r(__nested_webpack_exports__);\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"Promise\", (function() {\n\t            return promise_ZalgoPromise;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"TYPES\", (function() {\n\t            return src_types_TYPES_0;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"ProxyWindow\", (function() {\n\t            return window_ProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"setup\", (function() {\n\t            return setup;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"destroy\", (function() {\n\t            return destroy;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"serializeMessage\", (function() {\n\t            return setup_serializeMessage;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"deserializeMessage\", (function() {\n\t            return setup_deserializeMessage;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"createProxyWindow\", (function() {\n\t            return createProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"toProxyWindow\", (function() {\n\t            return setup_toProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"on\", (function() {\n\t            return on_on;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"once\", (function() {\n\t            return on_once;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"send\", (function() {\n\t            return send_send;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"markWindowKnown\", (function() {\n\t            return markWindowKnown;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"cleanUpWindow\", (function() {\n\t            return cleanUpWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"bridge\", (function() {}));\n\t        function isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\t        function getActualProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return win.location.protocol;\n\t        }\n\t        function getProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            if (win.mockDomain) {\n\t                var protocol = win.mockDomain.split(\"//\")[0];\n\t                if (protocol) return protocol;\n\t            }\n\t            return getActualProtocol(win);\n\t        }\n\t        function isAboutProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return \"about:\" === getProtocol(win);\n\t        }\n\t        function getParent(win) {\n\t            void 0 === win && (win = window);\n\t            if (win) try {\n\t                if (win.parent && win.parent !== win) return win.parent;\n\t            } catch (err) {}\n\t        }\n\t        function getOpener(win) {\n\t            void 0 === win && (win = window);\n\t            if (win && !getParent(win)) try {\n\t                return win.opener;\n\t            } catch (err) {}\n\t        }\n\t        function canReadFromWindow(win) {\n\t            try {\n\t                return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function getActualDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var location = win.location;\n\t            if (!location) throw new Error(\"Can not read window location\");\n\t            var protocol = getActualProtocol(win);\n\t            if (!protocol) throw new Error(\"Can not read window protocol\");\n\t            if (\"file:\" === protocol) return \"file://\";\n\t            if (\"about:\" === protocol) {\n\t                var parent = getParent(win);\n\t                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n\t            }\n\t            var host = location.host;\n\t            if (!host) throw new Error(\"Can not read window host\");\n\t            return protocol + \"//\" + host;\n\t        }\n\t        function getDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var domain = getActualDomain(win);\n\t            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n\t        }\n\t        function isSameDomain(win) {\n\t            if (!function(win) {\n\t                try {\n\t                    if (win === window) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\t                    if (desc && !1 === desc.enumerable) return !1;\n\t                } catch (err) {}\n\t                try {\n\t                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (function(win) {\n\t                        void 0 === win && (win = window);\n\t                        return \"mock:\" === getProtocol(win);\n\t                    }(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n\t                } catch (err) {}\n\t                return false;\n\t            }(win)) return false;\n\t            try {\n\t                if (win === window) return !0;\n\t                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                if (getDomain(window) === getDomain(win)) return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function assertSameDomain(win) {\n\t            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n\t            return win;\n\t        }\n\t        function isAncestorParent(parent, child) {\n\t            if (!parent || !child) return false;\n\t            var childParent = getParent(child);\n\t            return childParent ? childParent === parent : -1 !== function(win) {\n\t                var result = [];\n\t                try {\n\t                    for (;win.parent !== win; ) {\n\t                        result.push(win.parent);\n\t                        win = win.parent;\n\t                    }\n\t                } catch (err) {}\n\t                return result;\n\t            }(child).indexOf(parent);\n\t        }\n\t        function getFrames(win) {\n\t            var result = [];\n\t            var frames;\n\t            try {\n\t                frames = win.frames;\n\t            } catch (err) {\n\t                frames = win;\n\t            }\n\t            var len;\n\t            try {\n\t                len = frames.length;\n\t            } catch (err) {}\n\t            if (0 === len) return result;\n\t            if (len) {\n\t                for (var i = 0; i < len; i++) {\n\t                    var frame = void 0;\n\t                    try {\n\t                        frame = frames[i];\n\t                    } catch (err) {\n\t                        continue;\n\t                    }\n\t                    result.push(frame);\n\t                }\n\t                return result;\n\t            }\n\t            for (var _i = 0; _i < 100; _i++) {\n\t                var _frame = void 0;\n\t                try {\n\t                    _frame = frames[_i];\n\t                } catch (err) {\n\t                    return result;\n\t                }\n\t                if (!_frame) return result;\n\t                result.push(_frame);\n\t            }\n\t            return result;\n\t        }\n\t        var iframeWindows = [];\n\t        var iframeFrames = [];\n\t        function isWindowClosed(win, allowMock) {\n\t            void 0 === allowMock && (allowMock = true);\n\t            try {\n\t                if (win === window) return !1;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (!win) return !0;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (win.closed) return !0;\n\t            } catch (err) {\n\t                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n\t            }\n\t            if (allowMock && isSameDomain(win)) try {\n\t                if (win.mockclosed) return !0;\n\t            } catch (err) {}\n\t            try {\n\t                if (!win.parent || !win.top) return !0;\n\t            } catch (err) {}\n\t            var iframeIndex = function(collection, item) {\n\t                for (var i = 0; i < collection.length; i++) try {\n\t                    if (collection[i] === item) return i;\n\t                } catch (err) {}\n\t                return -1;\n\t            }(iframeWindows, win);\n\t            if (-1 !== iframeIndex) {\n\t                var frame = iframeFrames[iframeIndex];\n\t                if (frame && function(frame) {\n\t                    if (!frame.contentWindow) return true;\n\t                    if (!frame.parentNode) return true;\n\t                    var doc = frame.ownerDocument;\n\t                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n\t                        var parent = frame;\n\t                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n\t                        if (!parent.host || !doc.documentElement.contains(parent.host)) return true;\n\t                    }\n\t                    return false;\n\t                }(frame)) return true;\n\t            }\n\t            return false;\n\t        }\n\t        function getAncestor(win) {\n\t            void 0 === win && (win = window);\n\t            return getOpener(win = win || window) || getParent(win) || void 0;\n\t        }\n\t        function matchDomain(pattern, origin) {\n\t            if (\"string\" == typeof pattern) {\n\t                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n\t                if (isRegex(origin)) return false;\n\t                if (Array.isArray(origin)) return false;\n\t            }\n\t            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n\t                return matchDomain(subpattern, origin);\n\t            })));\n\t        }\n\t        function isWindow(obj) {\n\t            try {\n\t                if (obj === window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (window.Window && obj instanceof window.Window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.self === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.parent === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.top === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function getFrameForWindow(win) {\n\t            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\t            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n\t                var frame = _document$querySelect2[_i21];\n\t                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n\t            }\n\t        }\n\t        function closeWindow(win) {\n\t            if (function(win) {\n\t                void 0 === win && (win = window);\n\t                return Boolean(getParent(win));\n\t            }(win)) {\n\t                var frame = getFrameForWindow(win);\n\t                if (frame && frame.parentElement) {\n\t                    frame.parentElement.removeChild(frame);\n\t                    return;\n\t                }\n\t            }\n\t            try {\n\t                win.close();\n\t            } catch (err) {}\n\t        }\n\t        function utils_isPromise(item) {\n\t            try {\n\t                if (!item) return !1;\n\t                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n\t                var _toString = {}.toString;\n\t                if (_toString) {\n\t                    var name = _toString.call(item);\n\t                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n\t                }\n\t                if (\"function\" == typeof item.then) return !0;\n\t            } catch (err) {\n\t                return false;\n\t            }\n\t            return false;\n\t        }\n\t        var dispatchedErrors = [];\n\t        var possiblyUnhandledPromiseHandlers = [];\n\t        var activeCount = 0;\n\t        var flushPromise;\n\t        function flushActive() {\n\t            if (!activeCount && flushPromise) {\n\t                var promise = flushPromise;\n\t                flushPromise = null;\n\t                promise.resolve();\n\t            }\n\t        }\n\t        function startActive() {\n\t            activeCount += 1;\n\t        }\n\t        function endActive() {\n\t            activeCount -= 1;\n\t            flushActive();\n\t        }\n\t        var promise_ZalgoPromise = function() {\n\t            function ZalgoPromise(handler) {\n\t                var _this = this;\n\t                this.resolved = void 0;\n\t                this.rejected = void 0;\n\t                this.errorHandled = void 0;\n\t                this.value = void 0;\n\t                this.error = void 0;\n\t                this.handlers = void 0;\n\t                this.dispatching = void 0;\n\t                this.stack = void 0;\n\t                this.resolved = false;\n\t                this.rejected = false;\n\t                this.errorHandled = false;\n\t                this.handlers = [];\n\t                if (handler) {\n\t                    var _result;\n\t                    var _error;\n\t                    var resolved = false;\n\t                    var rejected = false;\n\t                    var isAsync = false;\n\t                    startActive();\n\t                    try {\n\t                        handler((function(res) {\n\t                            if (isAsync) _this.resolve(res); else {\n\t                                resolved = !0;\n\t                                _result = res;\n\t                            }\n\t                        }), (function(err) {\n\t                            if (isAsync) _this.reject(err); else {\n\t                                rejected = !0;\n\t                                _error = err;\n\t                            }\n\t                        }));\n\t                    } catch (err) {\n\t                        endActive();\n\t                        this.reject(err);\n\t                        return;\n\t                    }\n\t                    endActive();\n\t                    isAsync = true;\n\t                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n\t                }\n\t            }\n\t            var _proto = ZalgoPromise.prototype;\n\t            _proto.resolve = function(result) {\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n\t                this.resolved = true;\n\t                this.value = result;\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.reject = function(error) {\n\t                var _this2 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\t                if (!error) {\n\t                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\t                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n\t                }\n\t                this.rejected = true;\n\t                this.error = error;\n\t                this.errorHandled || setTimeout((function() {\n\t                    _this2.errorHandled || function(err, promise) {\n\t                        if (-1 === dispatchedErrors.indexOf(err)) {\n\t                            dispatchedErrors.push(err);\n\t                            setTimeout((function() {\n\t                                throw err;\n\t                            }), 1);\n\t                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n\t                        }\n\t                    }(error, _this2);\n\t                }), 1);\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.asyncReject = function(error) {\n\t                this.errorHandled = true;\n\t                this.reject(error);\n\t                return this;\n\t            };\n\t            _proto.dispatch = function() {\n\t                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n\t                if (!this.dispatching && (resolved || rejected)) {\n\t                    this.dispatching = true;\n\t                    startActive();\n\t                    var chain = function(firstPromise, secondPromise) {\n\t                        return firstPromise.then((function(res) {\n\t                            secondPromise.resolve(res);\n\t                        }), (function(err) {\n\t                            secondPromise.reject(err);\n\t                        }));\n\t                    };\n\t                    for (var i = 0; i < handlers.length; i++) {\n\t                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n\t                        var _result2 = void 0;\n\t                        if (resolved) try {\n\t                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n\t                        } catch (err) {\n\t                            promise.reject(err);\n\t                            continue;\n\t                        } else if (rejected) {\n\t                            if (!onError) {\n\t                                promise.reject(this.error);\n\t                                continue;\n\t                            }\n\t                            try {\n\t                                _result2 = onError(this.error);\n\t                            } catch (err) {\n\t                                promise.reject(err);\n\t                                continue;\n\t                            }\n\t                        }\n\t                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n\t                            var promiseResult = _result2;\n\t                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n\t                            promiseResult.errorHandled = true;\n\t                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n\t                    }\n\t                    handlers.length = 0;\n\t                    this.dispatching = false;\n\t                    endActive();\n\t                }\n\t            };\n\t            _proto.then = function(onSuccess, onError) {\n\t                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n\t                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n\t                var promise = new ZalgoPromise;\n\t                this.handlers.push({\n\t                    promise: promise,\n\t                    onSuccess: onSuccess,\n\t                    onError: onError\n\t                });\n\t                this.errorHandled = true;\n\t                this.dispatch();\n\t                return promise;\n\t            };\n\t            _proto.catch = function(onError) {\n\t                return this.then(void 0, onError);\n\t            };\n\t            _proto.finally = function(onFinally) {\n\t                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n\t                return this.then((function(result) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        return result;\n\t                    }));\n\t                }), (function(err) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        throw err;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.timeout = function(time, err) {\n\t                var _this3 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                var timeout = setTimeout((function() {\n\t                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n\t                }), time);\n\t                return this.then((function(result) {\n\t                    clearTimeout(timeout);\n\t                    return result;\n\t                }));\n\t            };\n\t            _proto.toPromise = function() {\n\t                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n\t                return Promise.resolve(this);\n\t            };\n\t            _proto.lazy = function() {\n\t                this.errorHandled = true;\n\t                return this;\n\t            };\n\t            ZalgoPromise.resolve = function(value) {\n\t                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n\t                    return value.then(resolve, reject);\n\t                })) : (new ZalgoPromise).resolve(value);\n\t            };\n\t            ZalgoPromise.reject = function(error) {\n\t                return (new ZalgoPromise).reject(error);\n\t            };\n\t            ZalgoPromise.asyncReject = function(error) {\n\t                return (new ZalgoPromise).asyncReject(error);\n\t            };\n\t            ZalgoPromise.all = function(promises) {\n\t                var promise = new ZalgoPromise;\n\t                var count = promises.length;\n\t                var results = [].slice();\n\t                if (!count) {\n\t                    promise.resolve(results);\n\t                    return promise;\n\t                }\n\t                var chain = function(i, firstPromise, secondPromise) {\n\t                    return firstPromise.then((function(res) {\n\t                        results[i] = res;\n\t                        0 == (count -= 1) && promise.resolve(results);\n\t                    }), (function(err) {\n\t                        secondPromise.reject(err);\n\t                    }));\n\t                };\n\t                for (var i = 0; i < promises.length; i++) {\n\t                    var prom = promises[i];\n\t                    if (prom instanceof ZalgoPromise) {\n\t                        if (prom.resolved) {\n\t                            results[i] = prom.value;\n\t                            count -= 1;\n\t                            continue;\n\t                        }\n\t                    } else if (!utils_isPromise(prom)) {\n\t                        results[i] = prom;\n\t                        count -= 1;\n\t                        continue;\n\t                    }\n\t                    chain(i, ZalgoPromise.resolve(prom), promise);\n\t                }\n\t                0 === count && promise.resolve(results);\n\t                return promise;\n\t            };\n\t            ZalgoPromise.hash = function(promises) {\n\t                var result = {};\n\t                var awaitPromises = [];\n\t                var _loop = function(key) {\n\t                    if (promises.hasOwnProperty(key)) {\n\t                        var value = promises[key];\n\t                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n\t                            result[key] = res;\n\t                        }))) : result[key] = value;\n\t                    }\n\t                };\n\t                for (var key in promises) _loop(key);\n\t                return ZalgoPromise.all(awaitPromises).then((function() {\n\t                    return result;\n\t                }));\n\t            };\n\t            ZalgoPromise.map = function(items, method) {\n\t                return ZalgoPromise.all(items.map(method));\n\t            };\n\t            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n\t                return function(handler) {\n\t                    possiblyUnhandledPromiseHandlers.push(handler);\n\t                    return {\n\t                        cancel: function() {\n\t                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n\t                        }\n\t                    };\n\t                }(handler);\n\t            };\n\t            ZalgoPromise.try = function(method, context, args) {\n\t                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n\t                var result;\n\t                startActive();\n\t                try {\n\t                    result = method.apply(context, args || []);\n\t                } catch (err) {\n\t                    endActive();\n\t                    return ZalgoPromise.reject(err);\n\t                }\n\t                endActive();\n\t                return ZalgoPromise.resolve(result);\n\t            };\n\t            ZalgoPromise.delay = function(_delay) {\n\t                return new ZalgoPromise((function(resolve) {\n\t                    setTimeout(resolve, _delay);\n\t                }));\n\t            };\n\t            ZalgoPromise.isPromise = function(value) {\n\t                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n\t            };\n\t            ZalgoPromise.flush = function() {\n\t                return function(Zalgo) {\n\t                    var promise = flushPromise = flushPromise || new Zalgo;\n\t                    flushActive();\n\t                    return promise;\n\t                }(ZalgoPromise);\n\t            };\n\t            return ZalgoPromise;\n\t        }();\n\t        function util_safeIndexOf(collection, item) {\n\t            for (var i = 0; i < collection.length; i++) try {\n\t                if (collection[i] === item) return i;\n\t            } catch (err) {}\n\t            return -1;\n\t        }\n\t        var weakmap_CrossDomainSafeWeakMap = function() {\n\t            function CrossDomainSafeWeakMap() {\n\t                this.name = void 0;\n\t                this.weakmap = void 0;\n\t                this.keys = void 0;\n\t                this.values = void 0;\n\t                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n\t                if (function() {\n\t                    if (\"undefined\" == typeof WeakMap) return false;\n\t                    if (void 0 === Object.freeze) return false;\n\t                    try {\n\t                        var testWeakMap = new WeakMap;\n\t                        var testKey = {};\n\t                        Object.freeze(testKey);\n\t                        testWeakMap.set(testKey, \"__testvalue__\");\n\t                        return \"__testvalue__\" === testWeakMap.get(testKey);\n\t                    } catch (err) {\n\t                        return false;\n\t                    }\n\t                }()) try {\n\t                    this.weakmap = new WeakMap;\n\t                } catch (err) {}\n\t                this.keys = [];\n\t                this.values = [];\n\t            }\n\t            var _proto = CrossDomainSafeWeakMap.prototype;\n\t            _proto._cleanupClosedWindows = function() {\n\t                var weakmap = this.weakmap;\n\t                var keys = this.keys;\n\t                for (var i = 0; i < keys.length; i++) {\n\t                    var value = keys[i];\n\t                    if (isWindow(value) && isWindowClosed(value)) {\n\t                        if (weakmap) try {\n\t                            weakmap.delete(value);\n\t                        } catch (err) {}\n\t                        keys.splice(i, 1);\n\t                        this.values.splice(i, 1);\n\t                        i -= 1;\n\t                    }\n\t                }\n\t            };\n\t            _proto.isSafeToReadWrite = function(key) {\n\t                return !isWindow(key);\n\t            };\n\t            _proto.set = function(key, value) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.set(key, value);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var name = this.name;\n\t                    var entry = key[name];\n\t                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n\t                        value: [ key, value ],\n\t                        writable: !0\n\t                    });\n\t                    return;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var values = this.values;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 === index) {\n\t                    keys.push(key);\n\t                    values.push(value);\n\t                } else values[index] = value;\n\t            };\n\t            _proto.get = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return weakmap.get(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return entry && entry[0] === key ? entry[1] : void 0;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var index = util_safeIndexOf(this.keys, key);\n\t                if (-1 !== index) return this.values[index];\n\t            };\n\t            _proto.delete = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.delete(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 !== index) {\n\t                    keys.splice(index, 1);\n\t                    this.values.splice(index, 1);\n\t                }\n\t            };\n\t            _proto.has = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return !0;\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return !(!entry || entry[0] !== key);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                return -1 !== util_safeIndexOf(this.keys, key);\n\t            };\n\t            _proto.getOrSet = function(key, getter) {\n\t                if (this.has(key)) return this.get(key);\n\t                var value = getter();\n\t                this.set(key, value);\n\t                return value;\n\t            };\n\t            return CrossDomainSafeWeakMap;\n\t        }();\n\t        function getFunctionName(fn) {\n\t            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n\t        }\n\t        function setFunctionName(fn, name) {\n\t            try {\n\t                delete fn.name;\n\t                fn.name = name;\n\t            } catch (err) {}\n\t            fn.__name__ = fn.displayName = name;\n\t            return fn;\n\t        }\n\t        function uniqueID() {\n\t            var chars = \"0123456789abcdef\";\n\t            return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, (function() {\n\t                return chars.charAt(Math.floor(Math.random() * chars.length));\n\t            })) + \"_\" + function(str) {\n\t                if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n\t                    return String.fromCharCode(parseInt(p1, 16));\n\t                }))).replace(/[=]/g, \"\");\n\t                if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n\t                throw new Error(\"Can not find window.btoa or Buffer\");\n\t            }((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n\t        }\n\t        var objectIDs;\n\t        function serializeArgs(args) {\n\t            try {\n\t                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n\t                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n\t                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n\t                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n\t                        var uid = objectIDs.get(obj);\n\t                        if (!uid) {\n\t                            uid = typeof obj + \":\" + uniqueID();\n\t                            objectIDs.set(obj, uid);\n\t                        }\n\t                        return uid;\n\t                    }(val) + \"]\" : \"undefined\" != typeof window && val instanceof window.Element || null !== val && \"object\" == typeof val && 1 === val.nodeType && \"object\" == typeof val.style && \"object\" == typeof val.ownerDocument ? {} : val;\n\t                }));\n\t            } catch (err) {\n\t                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n\t            }\n\t        }\n\t        function getEmptyObject() {\n\t            return {};\n\t        }\n\t        var memoizeGlobalIndex = 0;\n\t        var memoizeGlobalIndexValidFrom = 0;\n\t        function memoize(method, options) {\n\t            void 0 === options && (options = {});\n\t            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n\t            var simpleCache;\n\t            var thisCache;\n\t            var memoizeIndex = memoizeGlobalIndex;\n\t            memoizeGlobalIndex += 1;\n\t            var memoizedFunction = function() {\n\t                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\t                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n\t                    simpleCache = null;\n\t                    thisCache = null;\n\t                    memoizeIndex = memoizeGlobalIndex;\n\t                    memoizeGlobalIndex += 1;\n\t                }\n\t                var cache;\n\t                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n\t                var cacheKey;\n\t                try {\n\t                    cacheKey = serializeArgs(args);\n\t                } catch (_unused) {\n\t                    return method.apply(this, arguments);\n\t                }\n\t                var cacheResult = cache[cacheKey];\n\t                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n\t                    delete cache[cacheKey];\n\t                    cacheResult = null;\n\t                }\n\t                if (cacheResult) return cacheResult.value;\n\t                var time = Date.now();\n\t                var value = method.apply(this, arguments);\n\t                cache[cacheKey] = {\n\t                    time: time,\n\t                    value: value\n\t                };\n\t                return value;\n\t            };\n\t            memoizedFunction.reset = function() {\n\t                simpleCache = null;\n\t                thisCache = null;\n\t            };\n\t            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n\t        }\n\t        memoize.clear = function() {\n\t            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n\t        };\n\t        function memoizePromise(method) {\n\t            var cache = {};\n\t            function memoizedPromiseFunction() {\n\t                var _arguments = arguments, _this = this;\n\t                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\t                var key = serializeArgs(args);\n\t                if (cache.hasOwnProperty(key)) return cache[key];\n\t                cache[key] = promise_ZalgoPromise.try((function() {\n\t                    return method.apply(_this, _arguments);\n\t                })).finally((function() {\n\t                    delete cache[key];\n\t                }));\n\t                return cache[key];\n\t            }\n\t            memoizedPromiseFunction.reset = function() {\n\t                cache = {};\n\t            };\n\t            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n\t        }\n\t        function src_util_noop() {}\n\t        function stringifyError(err, level) {\n\t            void 0 === level && (level = 1);\n\t            if (level >= 3) return \"stringifyError stack overflow\";\n\t            try {\n\t                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n\t                if (\"string\" == typeof err) return err;\n\t                if (err instanceof Error) {\n\t                    var stack = err && err.stack;\n\t                    var message = err && err.message;\n\t                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n\t                    if (stack) return stack;\n\t                    if (message) return message;\n\t                }\n\t                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n\t            } catch (newErr) {\n\t                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n\t            }\n\t        }\n\t        function stringify(item) {\n\t            return \"string\" == typeof item ? item : item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n\t        }\n\t        memoize((function(obj) {\n\t            if (Object.values) return Object.values(obj);\n\t            var result = [];\n\t            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\t            return result;\n\t        }));\n\t        function util_isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        function util_getOrSet(obj, key, getter) {\n\t            if (obj.hasOwnProperty(key)) return obj[key];\n\t            var val = getter();\n\t            obj[key] = val;\n\t            return val;\n\t        }\n\t        function getBody() {\n\t            var body = document.body;\n\t            if (!body) throw new Error(\"Body element not found\");\n\t            return body;\n\t        }\n\t        function isDocumentReady() {\n\t            return Boolean(document.body) && \"complete\" === document.readyState;\n\t        }\n\t        function isDocumentInteractive() {\n\t            return Boolean(document.body) && \"interactive\" === document.readyState;\n\t        }\n\t        memoize((function() {\n\t            return new promise_ZalgoPromise((function(resolve) {\n\t                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n\t                var interval = setInterval((function() {\n\t                    if (isDocumentReady() || isDocumentInteractive()) {\n\t                        clearInterval(interval);\n\t                        return resolve();\n\t                    }\n\t                }), 10);\n\t            }));\n\t        }));\n\t        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n\t        var getCurrentScript = memoize((function() {\n\t            if (currentScript) return currentScript;\n\t            if (currentScript = function() {\n\t                try {\n\t                    var stack = function() {\n\t                        try {\n\t                            throw new Error(\"_\");\n\t                        } catch (err) {\n\t                            return err.stack || \"\";\n\t                        }\n\t                    }();\n\t                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n\t                    var scriptLocation = stackDetails && stackDetails[1];\n\t                    if (!scriptLocation) return;\n\t                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n\t                        var script = _Array$prototype$slic2[_i22];\n\t                        if (script.src && script.src === scriptLocation) return script;\n\t                    }\n\t                } catch (err) {}\n\t            }()) return currentScript;\n\t            throw new Error(\"Can not determine current script\");\n\t        }));\n\t        var currentUID = uniqueID();\n\t        memoize((function() {\n\t            var script;\n\t            try {\n\t                script = getCurrentScript();\n\t            } catch (err) {\n\t                return currentUID;\n\t            }\n\t            var uid = script.getAttribute(\"data-uid\");\n\t            if (uid && \"string\" == typeof uid) return uid;\n\t            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\t            if (script.src) {\n\t                var hashedString = function(str) {\n\t                    var hash = \"\";\n\t                    for (var i = 0; i < str.length; i++) {\n\t                        var total = str[i].charCodeAt(0) * i;\n\t                        str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n\t                        hash += String.fromCharCode(97 + Math.abs(total) % 26);\n\t                    }\n\t                    return hash;\n\t                }(JSON.stringify({\n\t                    src: script.src,\n\t                    dataset: script.dataset\n\t                }));\n\t                uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n\t            } else uid = uniqueID();\n\t            script.setAttribute(\"data-uid-auto\", uid);\n\t            return uid;\n\t        }));\n\t        function global_getGlobal(win) {\n\t            void 0 === win && (win = window);\n\t            var globalKey = \"__post_robot_10_0_46__\";\n\t            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n\t        }\n\t        var getObj = function() {\n\t            return {};\n\t        };\n\t        function globalStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return util_getOrSet(global_getGlobal(), key, (function() {\n\t                var store = defStore();\n\t                return {\n\t                    has: function(storeKey) {\n\t                        return store.hasOwnProperty(storeKey);\n\t                    },\n\t                    get: function(storeKey, defVal) {\n\t                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n\t                    },\n\t                    set: function(storeKey, val) {\n\t                        store[storeKey] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(storeKey) {\n\t                        delete store[storeKey];\n\t                    },\n\t                    getOrSet: function(storeKey, getter) {\n\t                        return util_getOrSet(store, storeKey, getter);\n\t                    },\n\t                    reset: function() {\n\t                        store = defStore();\n\t                    },\n\t                    keys: function() {\n\t                        return Object.keys(store);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        var WildCard = function() {};\n\t        function getWildcard() {\n\t            var global = global_getGlobal();\n\t            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n\t            return global.WINDOW_WILDCARD;\n\t        }\n\t        function windowStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return globalStore(\"windowStore\").getOrSet(key, (function() {\n\t                var winStore = new weakmap_CrossDomainSafeWeakMap;\n\t                var getStore = function(win) {\n\t                    return winStore.getOrSet(win, defStore);\n\t                };\n\t                return {\n\t                    has: function(win) {\n\t                        return getStore(win).hasOwnProperty(key);\n\t                    },\n\t                    get: function(win, defVal) {\n\t                        var store = getStore(win);\n\t                        return store.hasOwnProperty(key) ? store[key] : defVal;\n\t                    },\n\t                    set: function(win, val) {\n\t                        getStore(win)[key] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(win) {\n\t                        delete getStore(win)[key];\n\t                    },\n\t                    getOrSet: function(win, getter) {\n\t                        return util_getOrSet(getStore(win), key, getter);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        function getInstanceID() {\n\t            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n\t        }\n\t        function resolveHelloPromise(win, _ref) {\n\t            var domain = _ref.domain;\n\t            var helloPromises = windowStore(\"helloPromises\");\n\t            var existingPromise = helloPromises.get(win);\n\t            existingPromise && existingPromise.resolve({\n\t                domain: domain\n\t            });\n\t            var newPromise = promise_ZalgoPromise.resolve({\n\t                domain: domain\n\t            });\n\t            helloPromises.set(win, newPromise);\n\t            return newPromise;\n\t        }\n\t        function sayHello(win, _ref4) {\n\t            return (0, _ref4.send)(win, \"postrobot_hello\", {\n\t                instanceID: getInstanceID()\n\t            }, {\n\t                domain: \"*\",\n\t                timeout: -1\n\t            }).then((function(_ref5) {\n\t                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n\t                resolveHelloPromise(win, {\n\t                    domain: origin\n\t                });\n\t                return {\n\t                    win: win,\n\t                    domain: origin,\n\t                    instanceID: instanceID\n\t                };\n\t            }));\n\t        }\n\t        function getWindowInstanceID(win, _ref6) {\n\t            var send = _ref6.send;\n\t            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n\t                return sayHello(win, {\n\t                    send: send\n\t                }).then((function(_ref7) {\n\t                    return _ref7.instanceID;\n\t                }));\n\t            }));\n\t        }\n\t        function markWindowKnown(win) {\n\t            windowStore(\"knownWindows\").set(win, true);\n\t        }\n\t        function isSerializedType(item) {\n\t            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n\t        }\n\t        function determineType(val) {\n\t            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n\t        }\n\t        function serializeType(type, val) {\n\t            return {\n\t                __type__: type,\n\t                __val__: val\n\t            };\n\t        }\n\t        var _SERIALIZER;\n\t        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n\t            return serializeType(\"error\", {\n\t                message: _ref.message,\n\t                stack: _ref.stack,\n\t                code: _ref.code,\n\t                data: _ref.data\n\t            });\n\t        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n\t            return serializeType(\"regex\", val.source);\n\t        }, _SERIALIZER.date = function(val) {\n\t            return serializeType(\"date\", val.toJSON());\n\t        }, _SERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _SERIALIZER[void 0] = function(val) {\n\t            return serializeType(\"undefined\", val);\n\t        }, _SERIALIZER);\n\t        var defaultSerializers = {};\n\t        var _DESERIALIZER;\n\t        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n\t            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.error = function(_ref2) {\n\t            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n\t            var error = new Error(_ref2.message);\n\t            error.code = code;\n\t            data && (error.data = data);\n\t            error.stack = stack + \"\\n\\n\" + error.stack;\n\t            return error;\n\t        }, _DESERIALIZER.promise = function() {\n\t            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.regex = function(val) {\n\t            return new RegExp(val);\n\t        }, _DESERIALIZER.date = function(val) {\n\t            return new Date(val);\n\t        }, _DESERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);\n\t        var defaultDeserializers = {};\n\t        new promise_ZalgoPromise((function(resolve) {\n\t            if (window.document && window.document.body) return resolve(window.document.body);\n\t            var interval = setInterval((function() {\n\t                if (window.document && window.document.body) {\n\t                    clearInterval(interval);\n\t                    return resolve(window.document.body);\n\t                }\n\t            }), 10);\n\t        }));\n\t        function cleanupProxyWindows() {\n\t            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\t            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n\t                var id = _idToProxyWindow$keys2[_i2];\n\t                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n\t            }\n\t        }\n\t        function getSerializedWindow(winPromise, _ref) {\n\t            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n\t            var windowNamePromise = winPromise.then((function(win) {\n\t                if (isSameDomain(win)) return assertSameDomain(win).name;\n\t            }));\n\t            var windowTypePromise = winPromise.then((function(window) {\n\t                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n\t                return getOpener(window) ? \"popup\" : \"iframe\";\n\t            }));\n\t            windowNamePromise.catch(src_util_noop);\n\t            windowTypePromise.catch(src_util_noop);\n\t            var getName = function() {\n\t                return winPromise.then((function(win) {\n\t                    if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n\t                }));\n\t            };\n\t            return {\n\t                id: id,\n\t                getType: function() {\n\t                    return windowTypePromise;\n\t                },\n\t                getInstanceID: memoizePromise((function() {\n\t                    return winPromise.then((function(win) {\n\t                        return getWindowInstanceID(win, {\n\t                            send: send\n\t                        });\n\t                    }));\n\t                })),\n\t                close: function() {\n\t                    return winPromise.then(closeWindow);\n\t                },\n\t                getName: getName,\n\t                focus: function() {\n\t                    return winPromise.then((function(win) {\n\t                        win.focus();\n\t                    }));\n\t                },\n\t                isClosed: function() {\n\t                    return winPromise.then((function(win) {\n\t                        return isWindowClosed(win);\n\t                    }));\n\t                },\n\t                setLocation: function(href, opts) {\n\t                    void 0 === opts && (opts = {});\n\t                    return winPromise.then((function(win) {\n\t                        var domain = window.location.protocol + \"//\" + window.location.host;\n\t                        var _opts$method = opts.method, method = void 0 === _opts$method ? \"get\" : _opts$method, body = opts.body;\n\t                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n\t                        if (\"post\" === method) return getName().then((function(name) {\n\t                            if (!name) throw new Error(\"Can not post to window without target name\");\n\t                            !function(_ref3) {\n\t                                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n\t                                var form = document.createElement(\"form\");\n\t                                form.setAttribute(\"target\", target);\n\t                                form.setAttribute(\"method\", method);\n\t                                form.setAttribute(\"action\", url);\n\t                                form.style.display = \"none\";\n\t                                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n\t                                    var _body$key;\n\t                                    var key = _Object$keys4[_i24];\n\t                                    var input = document.createElement(\"input\");\n\t                                    input.setAttribute(\"name\", key);\n\t                                    input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n\t                                    form.appendChild(input);\n\t                                }\n\t                                getBody().appendChild(form);\n\t                                form.submit();\n\t                                getBody().removeChild(form);\n\t                            }({\n\t                                url: href,\n\t                                target: name,\n\t                                method: method,\n\t                                body: body\n\t                            });\n\t                        }));\n\t                        if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n\t                        if (isSameDomain(win)) try {\n\t                            if (win.location && \"function\" == typeof win.location.replace) {\n\t                                win.location.replace(href);\n\t                                return;\n\t                            }\n\t                        } catch (err) {}\n\t                        win.location = href;\n\t                    }));\n\t                },\n\t                setName: function(name) {\n\t                    return winPromise.then((function(win) {\n\t                        var sameDomain = isSameDomain(win);\n\t                        var frame = getFrameForWindow(win);\n\t                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n\t                        assertSameDomain(win).name = name;\n\t                        frame && frame.setAttribute(\"name\", name);\n\t                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n\t                    }));\n\t                }\n\t            };\n\t        }\n\t        var window_ProxyWindow = function() {\n\t            function ProxyWindow(_ref2) {\n\t                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n\t                this.id = void 0;\n\t                this.isProxyWindow = true;\n\t                this.serializedWindow = void 0;\n\t                this.actualWindow = void 0;\n\t                this.actualWindowPromise = void 0;\n\t                this.send = void 0;\n\t                this.name = void 0;\n\t                this.actualWindowPromise = new promise_ZalgoPromise;\n\t                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send\n\t                });\n\t                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n\t                win && this.setWindow(win, {\n\t                    send: send\n\t                });\n\t            }\n\t            var _proto = ProxyWindow.prototype;\n\t            _proto.getID = function() {\n\t                return this.serializedWindow.id;\n\t            };\n\t            _proto.getType = function() {\n\t                return this.serializedWindow.getType();\n\t            };\n\t            _proto.isPopup = function() {\n\t                return this.getType().then((function(type) {\n\t                    return \"popup\" === type;\n\t                }));\n\t            };\n\t            _proto.setLocation = function(href, opts) {\n\t                var _this = this;\n\t                return this.serializedWindow.setLocation(href, opts).then((function() {\n\t                    return _this;\n\t                }));\n\t            };\n\t            _proto.getName = function() {\n\t                return this.serializedWindow.getName();\n\t            };\n\t            _proto.setName = function(name) {\n\t                var _this2 = this;\n\t                return this.serializedWindow.setName(name).then((function() {\n\t                    return _this2;\n\t                }));\n\t            };\n\t            _proto.close = function() {\n\t                var _this3 = this;\n\t                return this.serializedWindow.close().then((function() {\n\t                    return _this3;\n\t                }));\n\t            };\n\t            _proto.focus = function() {\n\t                var _this4 = this;\n\t                var isPopupPromise = this.isPopup();\n\t                var getNamePromise = this.getName();\n\t                var reopenPromise = promise_ZalgoPromise.hash({\n\t                    isPopup: isPopupPromise,\n\t                    name: getNamePromise\n\t                }).then((function(_ref3) {\n\t                    var name = _ref3.name;\n\t                    _ref3.isPopup && name && window.open(\"\", name, \"noopener\");\n\t                }));\n\t                var focusPromise = this.serializedWindow.focus();\n\t                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n\t                    return _this4;\n\t                }));\n\t            };\n\t            _proto.isClosed = function() {\n\t                return this.serializedWindow.isClosed();\n\t            };\n\t            _proto.getWindow = function() {\n\t                return this.actualWindow;\n\t            };\n\t            _proto.setWindow = function(win, _ref4) {\n\t                var send = _ref4.send;\n\t                this.actualWindow = win;\n\t                this.actualWindowPromise.resolve(this.actualWindow);\n\t                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send,\n\t                    id: this.getID()\n\t                });\n\t                windowStore(\"winToProxyWindow\").set(win, this);\n\t            };\n\t            _proto.awaitWindow = function() {\n\t                return this.actualWindowPromise;\n\t            };\n\t            _proto.matchWindow = function(win, _ref5) {\n\t                var _this5 = this;\n\t                var send = _ref5.send;\n\t                return promise_ZalgoPromise.try((function() {\n\t                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n\t                        proxyInstanceID: _this5.getInstanceID(),\n\t                        knownWindowInstanceID: getWindowInstanceID(win, {\n\t                            send: send\n\t                        })\n\t                    }).then((function(_ref6) {\n\t                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n\t                        match && _this5.setWindow(win, {\n\t                            send: send\n\t                        });\n\t                        return match;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.unwrap = function() {\n\t                return this.actualWindow || this;\n\t            };\n\t            _proto.getInstanceID = function() {\n\t                return this.serializedWindow.getInstanceID();\n\t            };\n\t            _proto.shouldClean = function() {\n\t                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n\t            };\n\t            _proto.serialize = function() {\n\t                return this.serializedWindow;\n\t            };\n\t            ProxyWindow.unwrap = function(win) {\n\t                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n\t            };\n\t            ProxyWindow.serialize = function(win, _ref7) {\n\t                var send = _ref7.send;\n\t                cleanupProxyWindows();\n\t                return ProxyWindow.toProxyWindow(win, {\n\t                    send: send\n\t                }).serialize();\n\t            };\n\t            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n\t                var send = _ref8.send;\n\t                cleanupProxyWindows();\n\t                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n\t                    serializedWindow: serializedWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            ProxyWindow.isProxyWindow = function(obj) {\n\t                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n\t            };\n\t            ProxyWindow.toProxyWindow = function(win, _ref9) {\n\t                var send = _ref9.send;\n\t                cleanupProxyWindows();\n\t                if (ProxyWindow.isProxyWindow(win)) return win;\n\t                var actualWindow = win;\n\t                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n\t                    win: actualWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            return ProxyWindow;\n\t        }();\n\t        function addMethod(id, val, name, source, domain) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n\t                val: val,\n\t                name: name,\n\t                domain: domain,\n\t                source: source\n\t            }); else {\n\t                proxyWindowMethods.del(id);\n\t                methodStore.getOrSet(source, (function() {\n\t                    return {};\n\t                }))[id] = {\n\t                    domain: domain,\n\t                    name: name,\n\t                    val: val,\n\t                    source: source\n\t                };\n\t            }\n\t        }\n\t        function lookupMethod(source, id) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            return methodStore.getOrSet(source, (function() {\n\t                return {};\n\t            }))[id] || proxyWindowMethods.get(id);\n\t        }\n\t        function function_serializeFunction(destination, domain, val, key, _ref3) {\n\t            on = (_ref = {\n\t                on: _ref3.on,\n\t                send: _ref3.send\n\t            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n\t                return on(\"postrobot_method\", {\n\t                    domain: \"*\"\n\t                }, (function(_ref2) {\n\t                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n\t                    var id = data.id, name = data.name;\n\t                    var meth = lookupMethod(source, id);\n\t                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n\t                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n\t                    return promise_ZalgoPromise.try((function() {\n\t                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n\t                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n\t                            send: send\n\t                        }).then((function(match) {\n\t                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n\t                        }));\n\t                    })).then((function() {\n\t                        return val.apply({\n\t                            source: source,\n\t                            origin: origin\n\t                        }, data.args);\n\t                    }), (function(err) {\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            if (val.onError) return val.onError(err);\n\t                        })).then((function() {\n\t                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n\t                                void 0 === args && (args = []);\n\t                                return (item = args, [].slice.call(item)).map((function(arg) {\n\t                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n\t                                })).join(\", \");\n\t                                var item;\n\t                            }(data.args) + \") failed\\n\\n\" + err.stack);\n\t                            throw err;\n\t                        }));\n\t                    })).then((function(result) {\n\t                        return {\n\t                            result: result,\n\t                            id: id,\n\t                            name: name\n\t                        };\n\t                    }));\n\t                }));\n\t            }));\n\t            var _ref, on, send;\n\t            var id = val.__id__ || uniqueID();\n\t            destination = window_ProxyWindow.unwrap(destination);\n\t            var name = val.__name__ || val.name || key;\n\t            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\t            if (window_ProxyWindow.isProxyWindow(destination)) {\n\t                addMethod(id, val, name, destination, domain);\n\t                destination.awaitWindow().then((function(win) {\n\t                    addMethod(id, val, name, win, domain);\n\t                }));\n\t            } else addMethod(id, val, name, destination, domain);\n\t            return serializeType(\"cross_domain_function\", {\n\t                id: id,\n\t                name: name\n\t            });\n\t        }\n\t        function serializeMessage(destination, domain, obj, _ref) {\n\t            var _serialize;\n\t            var on = _ref.on, send = _ref.send;\n\t            return function(obj, serializers) {\n\t                void 0 === serializers && (serializers = defaultSerializers);\n\t                var result = JSON.stringify(obj, (function(key) {\n\t                    var val = this[key];\n\t                    if (isSerializedType(this)) return val;\n\t                    var type = determineType(val);\n\t                    if (!type) return val;\n\t                    var serializer = serializers[type] || SERIALIZER[type];\n\t                    return serializer ? serializer(val, key) : val;\n\t                }));\n\t                return void 0 === result ? \"undefined\" : result;\n\t            }(obj, ((_serialize = {}).promise = function(val, key) {\n\t                return function(destination, domain, val, key, _ref) {\n\t                    return serializeType(\"cross_domain_zalgo_promise\", {\n\t                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n\t                            return val.then(resolve, reject);\n\t                        }), key, {\n\t                            on: _ref.on,\n\t                            send: _ref.send\n\t                        })\n\t                    });\n\t                }(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.function = function(val, key) {\n\t                return function_serializeFunction(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.object = function(val) {\n\t                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n\t                    send: send\n\t                })) : val;\n\t            }, _serialize));\n\t        }\n\t        function deserializeMessage(source, origin, message, _ref2) {\n\t            var _deserialize;\n\t            var send = _ref2.send;\n\t            return function(str, deserializers) {\n\t                void 0 === deserializers && (deserializers = defaultDeserializers);\n\t                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n\t                    if (isSerializedType(this)) return val;\n\t                    var type;\n\t                    var value;\n\t                    if (isSerializedType(val)) {\n\t                        type = val.__type__;\n\t                        value = val.__val__;\n\t                    } else {\n\t                        type = determineType(val);\n\t                        value = val;\n\t                    }\n\t                    if (!type) return value;\n\t                    var deserializer = deserializers[type] || DESERIALIZER[type];\n\t                    return deserializer ? deserializer(value, key) : value;\n\t                }));\n\t            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n\t                return function(source, origin, _ref2) {\n\t                    return new promise_ZalgoPromise(_ref2.then);\n\t                }(0, 0, serializedPromise);\n\t            }, _deserialize.cross_domain_function = function(serializedFunction) {\n\t                return function(source, origin, _ref4, _ref5) {\n\t                    var id = _ref4.id, name = _ref4.name;\n\t                    var send = _ref5.send;\n\t                    var getDeserializedFunction = function(opts) {\n\t                        void 0 === opts && (opts = {});\n\t                        function crossDomainFunctionWrapper() {\n\t                            var _arguments = arguments;\n\t                            return window_ProxyWindow.toProxyWindow(source, {\n\t                                send: send\n\t                            }).awaitWindow().then((function(win) {\n\t                                var meth = lookupMethod(win, id);\n\t                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n\t                                    source: window,\n\t                                    origin: getDomain()\n\t                                }, _arguments);\n\t                                var _args = [].slice.call(_arguments);\n\t                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: true\n\t                                }) : send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: false\n\t                                }).then((function(res) {\n\t                                    return res.data.result;\n\t                                }));\n\t                            })).catch((function(err) {\n\t                                throw err;\n\t                            }));\n\t                        }\n\t                        crossDomainFunctionWrapper.__name__ = name;\n\t                        crossDomainFunctionWrapper.__origin__ = origin;\n\t                        crossDomainFunctionWrapper.__source__ = source;\n\t                        crossDomainFunctionWrapper.__id__ = id;\n\t                        crossDomainFunctionWrapper.origin = origin;\n\t                        return crossDomainFunctionWrapper;\n\t                    };\n\t                    var crossDomainFunctionWrapper = getDeserializedFunction();\n\t                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n\t                        fireAndForget: true\n\t                    });\n\t                    return crossDomainFunctionWrapper;\n\t                }(source, origin, serializedFunction, {\n\t                    send: send\n\t                });\n\t            }, _deserialize.cross_domain_window = function(serializedWindow) {\n\t                return window_ProxyWindow.deserialize(serializedWindow, {\n\t                    send: send\n\t                });\n\t            }, _deserialize));\n\t        }\n\t        var SEND_MESSAGE_STRATEGIES = {};\n\t        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n\t            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n\t            win.postMessage(serializedMessage, domain);\n\t        };\n\t        function send_sendMessage(win, domain, message, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            return promise_ZalgoPromise.try((function() {\n\t                var domainBuffer = windowStore().getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                domainBuffer.buffer = domainBuffer.buffer || [];\n\t                domainBuffer.buffer.push(message);\n\t                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n\t                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n\t                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], \n\t                    _ref), {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                    var _ref;\n\t                    delete domainBuffer.buffer;\n\t                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n\t                    var errors = [];\n\t                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n\t                        var strategyName = strategies[_i2];\n\t                        try {\n\t                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\t                        } catch (err) {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n\t                        return i + \". \" + stringifyError(err);\n\t                    })).join(\"\\n\\n\"));\n\t                }));\n\t                return domainBuffer.flush.then((function() {\n\t                    delete domainBuffer.flush;\n\t                }));\n\t            })).then(src_util_noop);\n\t        }\n\t        function getResponseListener(hash) {\n\t            return globalStore(\"responseListeners\").get(hash);\n\t        }\n\t        function deleteResponseListener(hash) {\n\t            globalStore(\"responseListeners\").del(hash);\n\t        }\n\t        function isResponseListenerErrored(hash) {\n\t            return globalStore(\"erroredResponseListeners\").has(hash);\n\t        }\n\t        function getRequestListener(_ref) {\n\t            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n\t            var requestListeners = windowStore(\"requestListeners\");\n\t            \"*\" === win && (win = null);\n\t            \"*\" === domain && (domain = null);\n\t            if (!name) throw new Error(\"Name required to get request listener\");\n\t            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n\t                var winQualifier = _ref3[_i4];\n\t                if (winQualifier) {\n\t                    var nameListeners = requestListeners.get(winQualifier);\n\t                    if (nameListeners) {\n\t                        var domainListeners = nameListeners[name];\n\t                        if (domainListeners) {\n\t                            if (domain && \"string\" == typeof domain) {\n\t                                if (domainListeners[domain]) return domainListeners[domain];\n\t                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n\t                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n\t                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n\t                                }\n\t                            }\n\t                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function handleRequest(source, origin, message, _ref) {\n\t            var on = _ref.on, send = _ref.send;\n\t            var options = getRequestListener({\n\t                name: message.name,\n\t                win: source,\n\t                domain: origin\n\t            });\n\t            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\t            function sendResponse(ack, data, error) {\n\t                return promise_ZalgoPromise.flush().then((function() {\n\t                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                        return send_sendMessage(source, origin, {\n\t                            id: uniqueID(),\n\t                            origin: getDomain(window),\n\t                            type: \"postrobot_message_response\",\n\t                            hash: message.hash,\n\t                            name: message.name,\n\t                            ack: ack,\n\t                            data: data,\n\t                            error: error\n\t                        }, {\n\t                            on: on,\n\t                            send: send\n\t                        });\n\t                    } catch (err) {\n\t                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }\n\t                }));\n\t            }\n\t            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n\t                if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                    return send_sendMessage(source, origin, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_ack\",\n\t                        hash: message.hash,\n\t                        name: message.name\n\t                    }, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                }\n\t            })), promise_ZalgoPromise.try((function() {\n\t                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                return options.handler({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            })).then((function(data) {\n\t                return sendResponse(\"success\", data);\n\t            }), (function(error) {\n\t                return sendResponse(\"error\", null, error);\n\t            })) ]).then(src_util_noop).catch((function(err) {\n\t                if (options && options.handleError) return options.handleError(err);\n\t                throw err;\n\t            }));\n\t        }\n\t        function handleAck(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                try {\n\t                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n\t                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n\t                } catch (err) {\n\t                    options.promise.reject(err);\n\t                }\n\t                options.ack = true;\n\t            }\n\t        }\n\t        function handleResponse(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n\t                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n\t                var pattern;\n\t                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n\t                deleteResponseListener(message.hash);\n\t                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            }\n\t        }\n\t        function receive_receiveMessage(event, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            var receivedMessages = globalStore(\"receivedMessages\");\n\t            try {\n\t                if (!window || window.closed || !event.source) return;\n\t            } catch (err) {\n\t                return;\n\t            }\n\t            var source = event.source, origin = event.origin;\n\t            var messages = function(message, source, origin, _ref) {\n\t                var on = _ref.on, send = _ref.send;\n\t                var parsedMessage;\n\t                try {\n\t                    parsedMessage = deserializeMessage(source, origin, message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    return;\n\t                }\n\t                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n\t                    var parseMessages = parsedMessage.__post_robot_10_0_46__;\n\t                    if (Array.isArray(parseMessages)) return parseMessages;\n\t                }\n\t            }(event.data, source, origin, {\n\t                on: on,\n\t                send: send\n\t            });\n\t            if (messages) {\n\t                markWindowKnown(source);\n\t                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n\t                    var message = messages[_i2];\n\t                    if (receivedMessages.has(message.id)) return;\n\t                    receivedMessages.set(message.id, true);\n\t                    if (isWindowClosed(source) && !message.fireAndForget) return;\n\t                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\t                    try {\n\t                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n\t                            on: on,\n\t                            send: send\n\t                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n\t                    } catch (err) {\n\t                        setTimeout((function() {\n\t                            throw err;\n\t                        }), 0);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function on_on(name, options, handler) {\n\t            if (!name) throw new Error(\"Expected name\");\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            if (!handler) throw new Error(\"Expected handler\");\n\t            var requestListener = function addRequestListener(_ref4, listener) {\n\t                var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;\n\t                var requestListeners = windowStore(\"requestListeners\");\n\t                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\t                if (winCandidate && \"*\" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {\n\t                    var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {\n\t                        return addRequestListener({\n\t                            name: name,\n\t                            win: actualWin,\n\t                            domain: domain\n\t                        }, listener);\n\t                    }));\n\t                    return {\n\t                        cancel: function() {\n\t                            requestListenerPromise.then((function(requestListener) {\n\t                                return requestListener.cancel();\n\t                            }), src_util_noop);\n\t                        }\n\t                    };\n\t                }\n\t                var win = winCandidate;\n\t                if (Array.isArray(win)) {\n\t                    var listenersCollection = [];\n\t                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        domain: domain,\n\t                        win: _win2[_i8]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                if (Array.isArray(domain)) {\n\t                    var _listenersCollection = [];\n\t                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        win: win,\n\t                        domain: _domain2[_i12]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                var existingListener = getRequestListener({\n\t                    name: name,\n\t                    win: win,\n\t                    domain: domain\n\t                });\n\t                win && \"*\" !== win || (win = getWildcard());\n\t                var strDomain = (domain = domain || \"*\").toString();\n\t                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n\t                var winNameListeners = requestListeners.getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainListeners = util_getOrSet(winNameListeners, name, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainRegexListeners;\n\t                var winNameDomainRegexListener;\n\t                util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, \"__domain_regex__\", (function() {\n\t                    return [];\n\t                }))).push(winNameDomainRegexListener = {\n\t                    regex: domain,\n\t                    listener: listener\n\t                }) : winNameDomainListeners[strDomain] = listener;\n\t                return {\n\t                    cancel: function() {\n\t                        delete winNameDomainListeners[strDomain];\n\t                        if (winNameDomainRegexListener) {\n\t                            winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));\n\t                            winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;\n\t                        }\n\t                        Object.keys(winNameDomainListeners).length || delete winNameListeners[name];\n\t                        win && !Object.keys(winNameListeners).length && requestListeners.del(win);\n\t                    }\n\t                };\n\t            }({\n\t                name: name,\n\t                win: options.window,\n\t                domain: options.domain || \"*\"\n\t            }, {\n\t                handler: handler || options.handler,\n\t                handleError: options.errorHandler || function(err) {\n\t                    throw err;\n\t                }\n\t            });\n\t            return {\n\t                cancel: function() {\n\t                    requestListener.cancel();\n\t                }\n\t            };\n\t        }\n\t        function on_once(name, options, handler) {\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            var promise = new promise_ZalgoPromise;\n\t            var listener;\n\t            options.errorHandler = function(err) {\n\t                listener.cancel();\n\t                promise.reject(err);\n\t            };\n\t            listener = on_on(name, options, (function(event) {\n\t                listener.cancel();\n\t                promise.resolve(event);\n\t                if (handler) return handler(event);\n\t            }));\n\t            promise.cancel = listener.cancel;\n\t            return promise;\n\t        }\n\t        var send_send = function send(winOrProxyWin, name, data, options) {\n\t            var domainMatcher = (options = options || {}).domain || \"*\";\n\t            var responseTimeout = options.timeout || -1;\n\t            var childTimeout = options.timeout || 5e3;\n\t            var fireAndForget = options.fireAndForget || false;\n\t            return window_ProxyWindow.toProxyWindow(winOrProxyWin, {\n\t                send: send\n\t            }).awaitWindow().then((function(win) {\n\t                return promise_ZalgoPromise.try((function() {\n\t                    !function(name, win, domain) {\n\t                        if (!name) throw new Error(\"Expected name\");\n\t                        if (\"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n\t                        if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n\t                    }(name, win, domainMatcher);\n\t                    if (function(parent, child) {\n\t                        var actualParent = getAncestor(child);\n\t                        if (actualParent) return actualParent === parent;\n\t                        if (child === parent) return false;\n\t                        if (function(win) {\n\t                            void 0 === win && (win = window);\n\t                            try {\n\t                                if (win.top) return win.top;\n\t                            } catch (err) {}\n\t                            if (getParent(win) === win) return win;\n\t                            try {\n\t                                if (isAncestorParent(window, win) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            try {\n\t                                if (isAncestorParent(win, window) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            for (var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {\n\t                                var result = [];\n\t                                for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n\t                                    var frame = _getFrames2[_i3];\n\t                                    result.push(frame);\n\t                                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n\t                                }\n\t                                return result;\n\t                            }(win); _i7 < _getAllChildFrames4.length; _i7++) {\n\t                                var frame = _getAllChildFrames4[_i7];\n\t                                try {\n\t                                    if (frame.top) return frame.top;\n\t                                } catch (err) {}\n\t                                if (getParent(frame) === frame) return frame;\n\t                            }\n\t                        }(child) === child) return false;\n\t                        for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return true;\n\t                        return false;\n\t                    }(window, win)) return function(win, timeout, name) {\n\t                        void 0 === timeout && (timeout = 5e3);\n\t                        void 0 === name && (name = \"Window\");\n\t                        var promise = function(win) {\n\t                            return windowStore(\"helloPromises\").getOrSet(win, (function() {\n\t                                return new promise_ZalgoPromise;\n\t                            }));\n\t                        }(win);\n\t                        -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n\t                        return promise;\n\t                    }(win, childTimeout);\n\t                })).then((function(_temp) {\n\t                    return function(win, targetDomain, actualDomain, _ref) {\n\t                        var send = _ref.send;\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n\t                                return actualDomain || sayHello(win, {\n\t                                    send: send\n\t                                }).then((function(_ref2) {\n\t                                    return _ref2.domain;\n\t                                }));\n\t                            })).then((function(normalizedDomain) {\n\t                                if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n\t                                return normalizedDomain;\n\t                            }));\n\t                        }));\n\t                    }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n\t                        send: send\n\t                    });\n\t                })).then((function(targetDomain) {\n\t                    var domain = targetDomain;\n\t                    var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n\t                    var promise = new promise_ZalgoPromise;\n\t                    var hash = name + \"_\" + uniqueID();\n\t                    if (!fireAndForget) {\n\t                        var responseListener = {\n\t                            name: name,\n\t                            win: win,\n\t                            domain: domain,\n\t                            promise: promise\n\t                        };\n\t                        !function(hash, listener) {\n\t                            globalStore(\"responseListeners\").set(hash, listener);\n\t                        }(hash, responseListener);\n\t                        var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n\t                            return [];\n\t                        }));\n\t                        reqPromises.push(promise);\n\t                        promise.catch((function() {\n\t                            !function(hash) {\n\t                                globalStore(\"erroredResponseListeners\").set(hash, true);\n\t                            }(hash);\n\t                            deleteResponseListener(hash);\n\t                        }));\n\t                        var totalAckTimeout = function(win) {\n\t                            return windowStore(\"knownWindows\").get(win, false);\n\t                        }(win) ? 1e4 : 2e3;\n\t                        var totalResTimeout = responseTimeout;\n\t                        var ackTimeout = totalAckTimeout;\n\t                        var resTimeout = totalResTimeout;\n\t                        var interval = function(method, time) {\n\t                            var timeout;\n\t                            !function loop() {\n\t                                timeout = setTimeout((function() {\n\t                                    !function() {\n\t                                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n\t                                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n\t                                        ackTimeout = Math.max(ackTimeout - 500, 0);\n\t                                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n\t                                        responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n\t                                    }();\n\t                                    loop();\n\t                                }), 500);\n\t                            }();\n\t                            return {\n\t                                cancel: function() {\n\t                                    clearTimeout(timeout);\n\t                                }\n\t                            };\n\t                        }();\n\t                        promise.finally((function() {\n\t                            interval.cancel();\n\t                            reqPromises.splice(reqPromises.indexOf(promise, 1));\n\t                        })).catch(src_util_noop);\n\t                    }\n\t                    return send_sendMessage(win, domain, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_request\",\n\t                        hash: hash,\n\t                        name: name,\n\t                        data: data,\n\t                        fireAndForget: fireAndForget\n\t                    }, {\n\t                        on: on_on,\n\t                        send: send\n\t                    }).then((function() {\n\t                        return fireAndForget ? promise.resolve() : promise;\n\t                    }), (function(err) {\n\t                        throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }));\n\t                }));\n\t            }));\n\t        };\n\t        function setup_serializeMessage(destination, domain, obj) {\n\t            return serializeMessage(destination, domain, obj, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup_deserializeMessage(source, origin, message) {\n\t            return deserializeMessage(source, origin, message, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function createProxyWindow(win) {\n\t            return new window_ProxyWindow({\n\t                send: send_send,\n\t                win: win\n\t            });\n\t        }\n\t        function setup_toProxyWindow(win) {\n\t            return window_ProxyWindow.toProxyWindow(win, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup() {\n\t            if (!global_getGlobal().initialized) {\n\t                global_getGlobal().initialized = true;\n\t                on = (_ref3 = {\n\t                    on: on_on,\n\t                    send: send_send\n\t                }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n\t                    return receive_receiveMessage(message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                };\n\t                !function(_ref5) {\n\t                    var on = _ref5.on, send = _ref5.send;\n\t                    globalStore().getOrSet(\"postMessageListener\", (function() {\n\t                        return function(obj, event, handler) {\n\t                            obj.addEventListener(\"message\", handler);\n\t                            return {\n\t                                cancel: function() {\n\t                                    obj.removeEventListener(\"message\", handler);\n\t                                }\n\t                            };\n\t                        }(window, 0, (function(event) {\n\t                            !function(event, _ref4) {\n\t                                var on = _ref4.on, send = _ref4.send;\n\t                                promise_ZalgoPromise.try((function() {\n\t                                    var source = event.source || event.sourceElement;\n\t                                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n\t                                    var data = event.data;\n\t                                    \"null\" === origin && (origin = \"file://\");\n\t                                    if (source) {\n\t                                        if (!origin) throw new Error(\"Post message did not have origin domain\");\n\t                                        receive_receiveMessage({\n\t                                            source: source,\n\t                                            origin: origin,\n\t                                            data: data\n\t                                        }, {\n\t                                            on: on,\n\t                                            send: send\n\t                                        });\n\t                                    }\n\t                                }));\n\t                            }(event, {\n\t                                on: on,\n\t                                send: send\n\t                            });\n\t                        }));\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t                !function(_ref8) {\n\t                    var on = _ref8.on, send = _ref8.send;\n\t                    globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n\t                        var listener = on(\"postrobot_hello\", {\n\t                            domain: \"*\"\n\t                        }, (function(_ref3) {\n\t                            resolveHelloPromise(_ref3.source, {\n\t                                domain: _ref3.origin\n\t                            });\n\t                            return {\n\t                                instanceID: getInstanceID()\n\t                            };\n\t                        }));\n\t                        var parent = getAncestor();\n\t                        parent && sayHello(parent, {\n\t                            send: send\n\t                        }).catch((function(err) {}));\n\t                        return listener;\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t            }\n\t            var _ref3, on, send, global;\n\t        }\n\t        function destroy() {\n\t            !function() {\n\t                var responseListeners = globalStore(\"responseListeners\");\n\t                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n\t                    var hash = _responseListeners$ke2[_i2];\n\t                    var listener = responseListeners.get(hash);\n\t                    listener && (listener.cancelled = true);\n\t                    responseListeners.del(hash);\n\t                }\n\t            }();\n\t            (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n\t            var listener;\n\t            delete window.__post_robot_10_0_46__;\n\t        }\n\t        var src_types_TYPES_0 = true;\n\t        function cleanUpWindow(win) {\n\t            for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n\t        }\n\t        setup();\n\t    } ]);\n\t})); \n} (postRobot));\n\nvar postRobotExports$1 = postRobot.exports;\n\n/* @flow */\n\n(function (module) {\n\t// $FlowFixMe\n\tmodule.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs\n\n\t// $FlowFixMe\n\tmodule.exports.default = module.exports; // eslint-disable-line import/no-commonjs \n} (postRobot$1));\n\nvar postRobotExports = postRobot$1.exports;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postRobotExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [postRobotExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL2luZGV4LUNzLW9ubnR2LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwrQkFBbUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLGtDQUFrQywrQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDhFQUE4RSwrQkFBbUI7QUFDakc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsK0JBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixzQkFBc0I7QUFDdEI7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixnQkFBZ0IsK0JBQW1CLENBQUMsK0JBQW1CO0FBQ3ZELE1BQU0sb0JBQW9CLDBCQUFtQixFQUFFLCtCQUFtQjtBQUNsRSxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRCxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQiwwQkFBMEI7QUFDNUU7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsNkJBQTZCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNQQUFzUCxLQUFLLHdDQUF3QyxLQUFLO0FBQ3hTLGtDQUFrQztBQUNsQztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9KQUFvSixxQ0FBcUM7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsd0JBQXdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZ0RBQWdELG9DQUFvQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsaUZBQWlGLDBCQUEwQjtBQUMzRztBQUNBO0FBQ0EsdUdBQXVHLGtDQUFrQztBQUN6STtBQUNBO0FBQ0EsOEJBQThCLE9BQU8sa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZFQUE2RSwyQkFBMkI7QUFDeEc7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHFDQUFxQztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxvQ0FBb0M7QUFDeEk7QUFDQTtBQUNBLE9BQU87QUFDUCxFQUFFO0FBQ0YsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLDBDQUEwQztBQUMxQyxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFdUIiLCJzb3VyY2VzIjpbIi9ob21lL2RlbWlnb2RqYXl5ZHkvRGVza3RvcC9wcm9qZWN0cy9yb3lhbFQvcm95YWxUL25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL2luZGV4LUNzLW9ubnR2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xuXHRtLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0XHRlICYmIHR5cGVvZiBlICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuXHRcdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBwb3N0Um9ib3QkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBwb3N0Um9ib3QgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQhZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgO1xuXHR9KFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogY29tbW9uanNHbG9iYWwsIChmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbihtb2R1bGVzKSB7XG5cdCAgICAgICAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0ICAgICAgICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdCAgICAgICAgICAgIGlmIChpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdCAgICAgICAgICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0ICAgICAgICAgICAgICAgIGk6IG1vZHVsZUlkLFxuXHQgICAgICAgICAgICAgICAgbDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0ICAgICAgICAgICAgbW9kdWxlLmwgPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG5cdCAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdCAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHQgICAgICAgICAgICAgICAgdmFsdWU6IFwiTW9kdWxlXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuXHQgICAgICAgICAgICAxICYgbW9kZSAmJiAodmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKSk7XG5cdCAgICAgICAgICAgIGlmICg4ICYgbW9kZSkgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICBpZiAoNCAmIG1vZGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsIFwiZGVmYXVsdFwiLCB7XG5cdCAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZiAoMiAmIG1vZGUgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdmFsdWUpIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG5cdCAgICAgICAgICAgIH0uYmluZChudWxsLCBrZXkpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5zO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdCAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZGVmYXVsdDtcblx0ICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgXCJhXCIsIGdldHRlcik7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblx0ICAgICAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcblx0ICAgIH0oWyBmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUHJvbWlzZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVFlQRVNcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc3JjX3R5cGVzX1RZUEVTXzA7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlByb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2V0dXBcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXA7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlc3Ryb3lcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGVzdHJveTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VyaWFsaXplTWVzc2FnZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cF9zZXJpYWxpemVNZXNzYWdlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZXNlcmlhbGl6ZU1lc3NhZ2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXBfZGVzZXJpYWxpemVNZXNzYWdlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjcmVhdGVQcm94eVdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eVdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidG9Qcm94eVdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cF90b1Byb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvblwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBvbl9vbjtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib25jZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBvbl9vbmNlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZW5kXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWFya1dpbmRvd0tub3duXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG1hcmtXaW5kb3dLbm93bjtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2xlYW5VcFdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjbGVhblVwV2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJicmlkZ2VcIiwgKGZ1bmN0aW9uKCkge30pKTtcblx0ICAgICAgICBmdW5jdGlvbiBpc1JlZ2V4KGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBJRV9XSU5fQUNDRVNTX0VSUk9SID0gXCJDYWxsIHdhcyByZWplY3RlZCBieSBjYWxsZWUuXFxyXFxuXCI7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0QWN0dWFsUHJvdG9jb2wod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luLmxvY2F0aW9uLnByb3RvY29sO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIGlmICh3aW4ubW9ja0RvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb3RvY29sID0gd2luLm1vY2tEb21haW4uc3BsaXQoXCIvL1wiKVswXTtcblx0ICAgICAgICAgICAgICAgIGlmIChwcm90b2NvbCkgcmV0dXJuIHByb3RvY29sO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRBY3R1YWxQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0Fib3V0UHJvdG9jb2wod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICByZXR1cm4gXCJhYm91dDpcIiA9PT0gZ2V0UHJvdG9jb2wod2luKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UGFyZW50KHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgaWYgKHdpbikgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4ucGFyZW50ICYmIHdpbi5wYXJlbnQgIT09IHdpbikgcmV0dXJuIHdpbi5wYXJlbnQ7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0T3BlbmVyKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgaWYgKHdpbiAmJiAhZ2V0UGFyZW50KHdpbikpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luLm9wZW5lcjtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbERvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHdpbi5sb2NhdGlvbjtcblx0ICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBsb2NhdGlvblwiKTtcblx0ICAgICAgICAgICAgdmFyIHByb3RvY29sID0gZ2V0QWN0dWFsUHJvdG9jb2wod2luKTtcblx0ICAgICAgICAgICAgaWYgKCFwcm90b2NvbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBwcm90b2NvbFwiKTtcblx0ICAgICAgICAgICAgaWYgKFwiZmlsZTpcIiA9PT0gcHJvdG9jb2wpIHJldHVybiBcImZpbGU6Ly9cIjtcblx0ICAgICAgICAgICAgaWYgKFwiYWJvdXQ6XCIgPT09IHByb3RvY29sKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KHdpbik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50ICYmIGNhblJlYWRGcm9tV2luZG93KCkgPyBnZXRBY3R1YWxEb21haW4ocGFyZW50KSA6IFwiYWJvdXQ6Ly9cIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgaG9zdCA9IGxvY2F0aW9uLmhvc3Q7XG5cdCAgICAgICAgICAgIGlmICghaG9zdCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBob3N0XCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXREb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0QWN0dWFsRG9tYWluKHdpbik7XG5cdCAgICAgICAgICAgIHJldHVybiBkb21haW4gJiYgd2luLm1vY2tEb21haW4gJiYgMCA9PT0gd2luLm1vY2tEb21haW4uaW5kZXhPZihcIm1vY2s6XCIpID8gd2luLm1vY2tEb21haW4gOiBkb21haW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzU2FtZURvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKCFmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW4sIFwibG9jYXRpb25cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgITEgPT09IGRlc2MuZW51bWVyYWJsZSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNBYm91dFByb3RvY29sKHdpbikgJiYgY2FuUmVhZEZyb21XaW5kb3coKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtb2NrOlwiID09PSBnZXRQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdygpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChnZXRBY3R1YWxEb21haW4od2luKSA9PT0gZ2V0QWN0dWFsRG9tYWluKHdpbmRvdykpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfSh3aW4pKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0Fib3V0UHJvdG9jb2wod2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdygpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICBpZiAoZ2V0RG9tYWluKHdpbmRvdykgPT09IGdldERvbWFpbih3aW4pKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBhc3NlcnRTYW1lRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICBpZiAoIWlzU2FtZURvbWFpbih3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB3aW5kb3cgdG8gYmUgc2FtZSBkb21haW5cIik7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzQW5jZXN0b3JQYXJlbnQocGFyZW50LCBjaGlsZCkge1xuXHQgICAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhY2hpbGQpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIGNoaWxkUGFyZW50ID0gZ2V0UGFyZW50KGNoaWxkKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNoaWxkUGFyZW50ID8gY2hpbGRQYXJlbnQgPT09IHBhcmVudCA6IC0xICE9PSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICg7d2luLnBhcmVudCAhPT0gd2luOyApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2luLnBhcmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbiA9IHdpbi5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgfShjaGlsZCkuaW5kZXhPZihwYXJlbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFtZXMod2luKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgdmFyIGZyYW1lcztcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGZyYW1lcyA9IHdpbi5mcmFtZXM7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgZnJhbWVzID0gd2luO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBsZW47XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBsZW4gPSBmcmFtZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIGlmICgwID09PSBsZW4pIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIGlmIChsZW4pIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCAxMDA7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IGZyYW1lc1tfaV07XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKCFfZnJhbWUpIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfZnJhbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpZnJhbWVXaW5kb3dzID0gW107XG5cdCAgICAgICAgdmFyIGlmcmFtZUZyYW1lcyA9IFtdO1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzV2luZG93Q2xvc2VkKHdpbiwgYWxsb3dNb2NrKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gYWxsb3dNb2NrICYmIChhbGxvd01vY2sgPSB0cnVlKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luLmNsb3NlZCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhZXJyIHx8IGVyci5tZXNzYWdlICE9PSBJRV9XSU5fQUNDRVNTX0VSUk9SO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChhbGxvd01vY2sgJiYgaXNTYW1lRG9tYWluKHdpbikpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luLm1vY2tjbG9zZWQpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF3aW4ucGFyZW50IHx8ICF3aW4udG9wKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgdmFyIGlmcmFtZUluZGV4ID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgfShpZnJhbWVXaW5kb3dzLCB3aW4pO1xuXHQgICAgICAgICAgICBpZiAoLTEgIT09IGlmcmFtZUluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBpZnJhbWVGcmFtZXNbaWZyYW1lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFtZS5jb250ZW50V2luZG93KSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLnBhcmVudE5vZGUpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBmcmFtZS5vd25lckRvY3VtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudCAmJiAhZG9jLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhmcmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGZyYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDtwYXJlbnQucGFyZW50Tm9kZSAmJiBwYXJlbnQucGFyZW50Tm9kZSAhPT0gcGFyZW50OyApIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5ob3N0IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHBhcmVudC5ob3N0KSkgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH0oZnJhbWUpKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEFuY2VzdG9yKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldE9wZW5lcih3aW4gPSB3aW4gfHwgd2luZG93KSB8fCBnZXRQYXJlbnQod2luKSB8fCB2b2lkIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG1hdGNoRG9tYWluKHBhdHRlcm4sIG9yaWdpbikge1xuXHQgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcGF0dGVybikge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG9yaWdpbikgcmV0dXJuIFwiKlwiID09PSBwYXR0ZXJuIHx8IG9yaWdpbiA9PT0gcGF0dGVybjtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1JlZ2V4KG9yaWdpbikpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gaXNSZWdleChwYXR0ZXJuKSA/IGlzUmVnZXgob3JpZ2luKSA/IHBhdHRlcm4udG9TdHJpbmcoKSA9PT0gb3JpZ2luLnRvU3RyaW5nKCkgOiAhQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIEJvb2xlYW4ob3JpZ2luLm1hdGNoKHBhdHRlcm4pKSA6ICEhQXJyYXkuaXNBcnJheShwYXR0ZXJuKSAmJiAoQXJyYXkuaXNBcnJheShvcmlnaW4pID8gSlNPTi5zdHJpbmdpZnkocGF0dGVybikgPT09IEpTT04uc3RyaW5naWZ5KG9yaWdpbikgOiAhaXNSZWdleChvcmlnaW4pICYmIHBhdHRlcm4uc29tZSgoZnVuY3Rpb24oc3VicGF0dGVybikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoRG9tYWluKHN1YnBhdHRlcm4sIG9yaWdpbik7XG5cdCAgICAgICAgICAgIH0pKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gd2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChcIltvYmplY3QgV2luZG93XVwiID09PSB7fS50b1N0cmluZy5jYWxsKG9iaikpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5XaW5kb3cgJiYgb2JqIGluc3RhbmNlb2Ygd2luZG93LldpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5zZWxmID09PSBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmoucGFyZW50ID09PSBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmoudG9wID09PSBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBcIl9fdW5saWtlbHlfdmFsdWVfX1wiID09PSBvYmouX19jcm9zc19kb21haW5fdXRpbHNfd2luZG93X2NoZWNrX18pIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwicG9zdE1lc3NhZ2VcIiBpbiBvYmogJiYgXCJzZWxmXCIgaW4gb2JqICYmIFwibG9jYXRpb25cIiBpbiBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYW1lRm9yV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKHdpbikpIHJldHVybiBhc3NlcnRTYW1lRG9tYWluKHdpbikuZnJhbWVFbGVtZW50O1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTIxID0gMCwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0MiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIik7IF9pMjEgPCBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyLmxlbmd0aDsgX2kyMSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyW19pMjFdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZyYW1lLmNvbnRlbnRXaW5kb3cgJiYgZnJhbWUuY29udGVudFdpbmRvdyA9PT0gd2luKSByZXR1cm4gZnJhbWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gY2xvc2VXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0UGFyZW50KHdpbikpO1xuXHQgICAgICAgICAgICB9KHdpbikpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGdldEZyYW1lRm9yV2luZG93KHdpbik7XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUucGFyZW50RWxlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZyYW1lLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgd2luLmNsb3NlKCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbHNfaXNQcm9taXNlKGl0ZW0pIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFByb21pc2UgJiYgaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW5kb3cuV2luZG93ICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LmNvbnN0cnVjdG9yICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuY29uc3RydWN0b3IpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIHZhciBfdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIGlmIChfdG9TdHJpbmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF90b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChcIltvYmplY3QgV2luZG93XVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBnbG9iYWxdXCIgPT09IG5hbWUgfHwgXCJbb2JqZWN0IERPTVdpbmRvd11cIiA9PT0gbmFtZSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlbS50aGVuKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRpc3BhdGNoZWRFcnJvcnMgPSBbXTtcblx0ICAgICAgICB2YXIgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMgPSBbXTtcblx0ICAgICAgICB2YXIgYWN0aXZlQ291bnQgPSAwO1xuXHQgICAgICAgIHZhciBmbHVzaFByb21pc2U7XG5cdCAgICAgICAgZnVuY3Rpb24gZmx1c2hBY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIGlmICghYWN0aXZlQ291bnQgJiYgZmx1c2hQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIGZsdXNoUHJvbWlzZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGFydEFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgYWN0aXZlQ291bnQgKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZW5kQWN0aXZlKCkge1xuXHQgICAgICAgICAgICBhY3RpdmVDb3VudCAtPSAxO1xuXHQgICAgICAgICAgICBmbHVzaEFjdGl2ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvbWlzZV9aYWxnb1Byb21pc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gWmFsZ29Qcm9taXNlKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2Vycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jKSBfdGhpcy5yZXNvbHZlKHJlcyk7IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdCA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jKSBfdGhpcy5yZWplY3QoZXJyKTsgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3IgPSBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaXNBc3luYyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPyB0aGlzLnJlc29sdmUoX3Jlc3VsdCkgOiByZWplY3RlZCAmJiB0aGlzLnJlamVjdChfZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBaYWxnb1Byb21pc2UucHJvdG90eXBlO1xuXHQgICAgICAgICAgICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKHJlc3VsdCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5yZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh1dGlsc19pc1Byb21pc2UoZXJyb3IpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlamVjdCBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfZXJyID0gZXJyb3IgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnJvci50b1N0cmluZyA/IGVycm9yLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkV4cGVjdGVkIHJlamVjdCB0byBiZSBjYWxsZWQgd2l0aCBFcnJvciwgZ290IFwiICsgX2Vycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkIHx8IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMi5lcnJvckhhbmRsZWQgfHwgZnVuY3Rpb24oZXJyLCBwcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gZGlzcGF0Y2hlZEVycm9ycy5pbmRleE9mKGVycikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZWRFcnJvcnMucHVzaChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5sZW5ndGg7IGorKykgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnNbal0oZXJyLCBwcm9taXNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0oZXJyb3IsIF90aGlzMik7XG5cdCAgICAgICAgICAgICAgICB9KSwgMSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmFzeW5jUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZGlzcGF0Y2ggPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZWQsIHJlamVjdGVkID0gdGhpcy5yZWplY3RlZCwgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BhdGNoaW5nICYmIChyZXNvbHZlZCB8fCByZWplY3RlZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKGZpcnN0UHJvbWlzZSwgc2Vjb25kUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaGFuZGxlcnMkaSA9IGhhbmRsZXJzW2ldLCBvblN1Y2Nlc3MgPSBfaGFuZGxlcnMkaS5vblN1Y2Nlc3MsIG9uRXJyb3IgPSBfaGFuZGxlcnMkaS5vbkVycm9yLCBwcm9taXNlID0gX2hhbmRsZXJzJGkucHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQyID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0MiA9IG9uU3VjY2VzcyA/IG9uU3VjY2Vzcyh0aGlzLnZhbHVlKSA6IHRoaXMudmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlamVjdGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBvbkVycm9yKHRoaXMuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlc3VsdDIgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgJiYgKF9yZXN1bHQyLnJlc29sdmVkIHx8IF9yZXN1bHQyLnJlamVjdGVkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VSZXN1bHQgPSBfcmVzdWx0Mjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXN1bHQucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUocHJvbWlzZVJlc3VsdC52YWx1ZSkgOiBwcm9taXNlLnJlamVjdChwcm9taXNlUmVzdWx0LmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXN1bHQuZXJyb3JIYW5kbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHV0aWxzX2lzUHJvbWlzZShfcmVzdWx0MikgPyBfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpID8gX3Jlc3VsdDIucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIudmFsdWUpIDogcHJvbWlzZS5yZWplY3QoX3Jlc3VsdDIuZXJyb3IpIDogY2hhaW4oX3Jlc3VsdDIsIHByb21pc2UpIDogcHJvbWlzZS5yZXNvbHZlKF9yZXN1bHQyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24ob25TdWNjZXNzLCBvbkVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob25TdWNjZXNzICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25TdWNjZXNzICYmICFvblN1Y2Nlc3MuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50aGVuIGV4cGVjdGVkIGEgZnVuY3Rpb24gZm9yIHN1Y2Nlc3MgaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChvbkVycm9yICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25FcnJvciAmJiAhb25FcnJvci5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3IgZXJyb3IgaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFphbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcblx0ICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IG9uU3VjY2Vzcyxcblx0ICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbihvbkVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgb25FcnJvcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24ob25GaW5hbGx5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob25GaW5hbGx5ICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25GaW5hbGx5ICYmICFvbkZpbmFsbHkuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS5maW5hbGx5IGV4cGVjdGVkIGEgZnVuY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShvbkZpbmFsbHkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS50cnkob25GaW5hbGx5KS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnRpbWVvdXQgPSBmdW5jdGlvbih0aW1lLCBlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMy5yZXNvbHZlZCB8fCBfdGhpczMucmVqZWN0ZWQgfHwgX3RoaXMzLnJlamVjdChlcnIgfHwgbmV3IEVycm9yKFwiUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aW1lICsgXCJtc1wiKSk7XG5cdCAgICAgICAgICAgICAgICB9KSwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnRvUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFByb21pc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb3VsZCBub3QgZmluZCBQcm9taXNlXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmxhenkgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgPyB2YWx1ZSA6IHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSkgPyBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfSkpIDogKG5ldyBaYWxnb1Byb21pc2UpLnJlc29sdmUodmFsdWUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFphbGdvUHJvbWlzZSkucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmFzeW5jUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFphbGdvUHJvbWlzZSkuYXN5bmNSZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuYWxsID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFphbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHByb21pc2VzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW10uc2xpY2UoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghY291bnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbihpLCBmaXJzdFByb21pc2UsIHNlY29uZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAwID09IChjb3VudCAtPSAxKSAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9tID0gcHJvbWlzZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb20gaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb20ucmVzb2x2ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdXRpbHNfaXNQcm9taXNlKHByb20pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW4oaSwgWmFsZ29Qcm9taXNlLnJlc29sdmUocHJvbSksIHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgMCA9PT0gY291bnQgJiYgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5oYXNoID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciBhd2FpdFByb21pc2VzID0gW107XG5cdCAgICAgICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9taXNlc1trZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1dGlsc19pc1Byb21pc2UodmFsdWUpID8gYXdhaXRQcm9taXNlcy5wdXNoKHZhbHVlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkgOiByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvbWlzZXMpIF9sb29wKGtleSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLmFsbChhd2FpdFByb21pc2VzKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UubWFwID0gZnVuY3Rpb24oaXRlbXMsIG1ldGhvZCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5hbGwoaXRlbXMubWFwKG1ldGhvZCkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuc3BsaWNlKHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLmluZGV4T2YoaGFuZGxlciksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0oaGFuZGxlcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS50cnkgPSBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIGFyZ3MpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChtZXRob2QgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBtZXRob2QgJiYgIW1ldGhvZC5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRyeSBleHBlY3RlZCBhIGZ1bmN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuZGVsYXkgPSBmdW5jdGlvbihfZGVsYXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBfZGVsYXkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuaXNQcm9taXNlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSkgfHwgdXRpbHNfaXNQcm9taXNlKHZhbHVlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oWmFsZ28pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZSA9IGZsdXNoUHJvbWlzZSB8fCBuZXcgWmFsZ287XG5cdCAgICAgICAgICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0oWmFsZ29Qcm9taXNlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZTtcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9zYWZlSW5kZXhPZihjb2xsZWN0aW9uLCBpdGVtKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXAgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gQ3Jvc3NEb21haW5TYWZlV2Vha01hcCgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMua2V5cyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJfX3dlYWttYXBfXCIgKyAoMWU5ICogTWF0aC5yYW5kb20oKSA+Pj4gMCkgKyBcIl9fXCI7XG5cdCAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBPYmplY3QuZnJlZXplKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RXZWFrTWFwID0gbmV3IFdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0S2V5ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGVzdEtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RXZWFrTWFwLnNldCh0ZXN0S2V5LCBcIl9fdGVzdHZhbHVlX19cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9fdGVzdHZhbHVlX19cIiA9PT0gdGVzdFdlYWtNYXAuZ2V0KHRlc3RLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSgpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IG5ldyBXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBDcm9zc0RvbWFpblNhZmVXZWFrTWFwLnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgX3Byb3RvLl9jbGVhbnVwQ2xvc2VkV2luZG93cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtleXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93KHZhbHVlKSAmJiBpc1dpbmRvd0Nsb3NlZCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmlzU2FmZVRvUmVhZFdyaXRlID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIWlzV2luZG93KGtleSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuc2V0KGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA9IHZhbHVlIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGtleSwgbmFtZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2Yoa2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gd2Vha21hcC5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGluZGV4KSByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZGVsZXRlID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuZGVsZXRlKGtleSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ICYmIChlbnRyeVswXSA9IGVudHJ5WzFdID0gdm9pZCAwKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2Yoa2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRPclNldCA9IGZ1bmN0aW9uKGtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmbi5uYW1lIHx8IGZuLl9fbmFtZV9fIHx8IGZuLmRpc3BsYXlOYW1lIHx8IFwiYW5vbnltb3VzXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldEZ1bmN0aW9uTmFtZShmbiwgbmFtZSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGZuLm5hbWU7XG5cdCAgICAgICAgICAgICAgICBmbi5uYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICBmbi5fX25hbWVfXyA9IGZuLmRpc3BsYXlOYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB1bmlxdWVJRCgpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5cdCAgICAgICAgICAgIHJldHVybiBcInVpZF9cIiArIFwieHh4eHh4eHh4eFwiLnJlcGxhY2UoLy4vZywgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcblx0ICAgICAgICAgICAgfSkpICsgXCJfXCIgKyBmdW5jdGlvbihzdHIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGJ0b2EpIHJldHVybiBidG9hKGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoLyUoWzAtOUEtRl17Mn0pL2csIChmdW5jdGlvbihtLCBwMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHAxLCAxNikpO1xuXHQgICAgICAgICAgICAgICAgfSkpKS5yZXBsYWNlKC9bPV0vZywgXCJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyKSByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvWz1dL2csIFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIHdpbmRvdy5idG9hIG9yIEJ1ZmZlclwiKTtcblx0ICAgICAgICAgICAgfSgobmV3IERhdGUpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMTEsIDE5KS5yZXBsYWNlKFwiVFwiLCBcIi5cIikpLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgb2JqZWN0SURzO1xuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUFyZ3MoYXJncykge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtdLnNsaWNlLmNhbGwoYXJncyksIChmdW5jdGlvbihzdWJrZXksIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbCA/IFwibWVtb2l6ZVtcIiArIGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMgPSBvYmplY3RJRHMgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gb2JqIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIG9iaiAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9iaikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3RcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSBvYmplY3RJRHMuZ2V0KG9iaik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdWlkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQgPSB0eXBlb2Ygb2JqICsgXCI6XCIgKyB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SURzLnNldChvYmosIHVpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgICAgICAgICB9KHZhbCkgKyBcIl1cIiA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiB2YWwgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudCB8fCBudWxsICE9PSB2YWwgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsICYmIDEgPT09IHZhbC5ub2RlVHlwZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwuc3R5bGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsLm93bmVyRG9jdW1lbnQgPyB7fSA6IHZhbDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudHMgbm90IHNlcmlhbGl6YWJsZSAtLSBjYW4gbm90IGJlIHVzZWQgdG8gbWVtb2l6ZVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRFbXB0eU9iamVjdCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4ID0gMDtcblx0ICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gMDtcblx0ICAgICAgICBmdW5jdGlvbiBtZW1vaXplKG1ldGhvZCwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IG9wdGlvbnMgJiYgKG9wdGlvbnMgPSB7fSk7XG5cdCAgICAgICAgICAgIHZhciBfb3B0aW9ucyR0aGlzTmFtZXNwYWMgPSBvcHRpb25zLnRoaXNOYW1lc3BhY2UsIHRoaXNOYW1lc3BhY2UgPSB2b2lkIDAgIT09IF9vcHRpb25zJHRoaXNOYW1lc3BhYyAmJiBfb3B0aW9ucyR0aGlzTmFtZXNwYWMsIGNhY2hlVGltZSA9IG9wdGlvbnMudGltZTtcblx0ICAgICAgICAgICAgdmFyIHNpbXBsZUNhY2hlO1xuXHQgICAgICAgICAgICB2YXIgdGhpc0NhY2hlO1xuXHQgICAgICAgICAgICB2YXIgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuXHQgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXggKz0gMTtcblx0ICAgICAgICAgICAgdmFyIG1lbW9pemVkRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgICAgICAgICAgICAgIGlmIChtZW1vaXplSW5kZXggPCBtZW1vaXplR2xvYmFsSW5kZXhWYWxpZEZyb20pIHtcblx0ICAgICAgICAgICAgICAgICAgICBzaW1wbGVDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICBtZW1vaXplSW5kZXggPSBtZW1vaXplR2xvYmFsSW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4ICs9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGU7XG5cdCAgICAgICAgICAgICAgICBjYWNoZSA9IHRoaXNOYW1lc3BhY2UgPyAodGhpc0NhY2hlID0gdGhpc0NhY2hlIHx8IG5ldyB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXApLmdldE9yU2V0KHRoaXMsIGdldEVtcHR5T2JqZWN0KSA6IHNpbXBsZUNhY2hlID0gc2ltcGxlQ2FjaGUgfHwge307XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGVSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQgJiYgY2FjaGVUaW1lICYmIERhdGUubm93KCkgLSBjYWNoZVJlc3VsdC50aW1lIDwgY2FjaGVUaW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2NhY2hlS2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZVJlc3VsdCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQpIHJldHVybiBjYWNoZVJlc3VsdC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBtZW1vaXplZEZ1bmN0aW9uLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBzaW1wbGVDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0RnVuY3Rpb25OYW1lKG1lbW9pemVkRnVuY3Rpb24sIChvcHRpb25zLm5hbWUgfHwgZ2V0RnVuY3Rpb25OYW1lKG1ldGhvZCkpICsgXCI6Om1lbW9pemVkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIG1lbW9pemVHbG9iYWxJbmRleFZhbGlkRnJvbSA9IG1lbW9pemVHbG9iYWxJbmRleDtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVQcm9taXNlKG1ldGhvZCkge1xuXHQgICAgICAgICAgICB2YXIgY2FjaGUgPSB7fTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cywgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gY2FjaGVba2V5XTtcblx0ICAgICAgICAgICAgICAgIGNhY2hlW2tleV0gPSBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgfSkpLmZpbmFsbHkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24ucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGNhY2hlID0ge307XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24sIGdldEZ1bmN0aW9uTmFtZShtZXRob2QpICsgXCI6OnByb21pc2VNZW1vaXplZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3JjX3V0aWxfbm9vcCgpIHt9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyLCBsZXZlbCkge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGxldmVsICYmIChsZXZlbCA9IDEpO1xuXHQgICAgICAgICAgICBpZiAobGV2ZWwgPj0gMykgcmV0dXJuIFwic3RyaW5naWZ5RXJyb3Igc3RhY2sgb3ZlcmZsb3dcIjtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghZXJyKSByZXR1cm4gXCI8dW5rbm93biBlcnJvcjogXCIgKyB7fS50b1N0cmluZy5jYWxsKGVycikgKyBcIj5cIjtcblx0ICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlcnIpIHJldHVybiBlcnI7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnIgJiYgZXJyLnN0YWNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBtZXNzYWdlKSByZXR1cm4gLTEgIT09IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPyBzdGFjayA6IG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrKSByZXR1cm4gc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHJldHVybiBtZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVyciAmJiBlcnIudG9TdHJpbmcgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnIudG9TdHJpbmcgPyBlcnIudG9TdHJpbmcoKSA6IHt9LnRvU3RyaW5nLmNhbGwoZXJyKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAobmV3RXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvciB3aGlsZSBzdHJpbmdpZnlpbmcgZXJyb3I6IFwiICsgc3RyaW5naWZ5RXJyb3IobmV3RXJyLCBsZXZlbCArIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtID8gaXRlbSA6IGl0ZW0udG9TdHJpbmcgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRvU3RyaW5nID8gaXRlbS50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKSByZXR1cm4gT2JqZWN0LnZhbHVlcyhvYmopO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHJlc3VsdC5wdXNoKG9ialtrZXldKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9pc1JlZ2V4KGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxfZ2V0T3JTZXQob2JqLCBrZXksIGdldHRlcikge1xuXHQgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBvYmpba2V5XTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IGdldHRlcigpO1xuXHQgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcblx0ICAgICAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXHQgICAgICAgICAgICBpZiAoIWJvZHkpIHRocm93IG5ldyBFcnJvcihcIkJvZHkgZWxlbWVudCBub3QgZm91bmRcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBib2R5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50UmVhZHkoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50LmJvZHkpICYmIFwiY29tcGxldGVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNEb2N1bWVudEludGVyYWN0aXZlKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudC5ib2R5KSAmJiBcImludGVyYWN0aXZlXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHJldHVybiByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRSZWFkeSgpIHx8IGlzRG9jdW1lbnRJbnRlcmFjdGl2ZSgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pLCAxMCk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRTY3JpcHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiBudWxsO1xuXHQgICAgICAgIHZhciBnZXRDdXJyZW50U2NyaXB0ID0gbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50U2NyaXB0KSByZXR1cm4gY3VycmVudFNjcmlwdDtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIuc3RhY2sgfHwgXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tEZXRhaWxzID0gLy4qYXQgW14oXSpcXCgoLiopOiguKyk6KC4rKVxcKSQvZ2kuZXhlYyhzdGFjayk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcmlwdExvY2F0aW9uID0gc3RhY2tEZXRhaWxzICYmIHN0YWNrRGV0YWlsc1sxXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNjcmlwdExvY2F0aW9uKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMiA9IDAsIF9BcnJheSRwcm90b3R5cGUkc2xpYzIgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKS5yZXZlcnNlKCk7IF9pMjIgPCBfQXJyYXkkcHJvdG90eXBlJHNsaWMyLmxlbmd0aDsgX2kyMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBfQXJyYXkkcHJvdG90eXBlJHNsaWMyW19pMjJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NyaXB0LnNyYyAmJiBzY3JpcHQuc3JjID09PSBzY3JpcHRMb2NhdGlvbikgcmV0dXJuIHNjcmlwdDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH0oKSkgcmV0dXJuIGN1cnJlbnRTY3JpcHQ7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGV0ZXJtaW5lIGN1cnJlbnQgc2NyaXB0XCIpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICB2YXIgY3VycmVudFVJRCA9IHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBzY3JpcHQ7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBzY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRVSUQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHVpZCA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVpZFwiKTtcblx0ICAgICAgICAgICAgaWYgKHVpZCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB1aWQpIHJldHVybiB1aWQ7XG5cdCAgICAgICAgICAgIGlmICgodWlkID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtdWlkLWF1dG9cIikpICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgaWYgKHNjcmlwdC5zcmMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBoYXNoZWRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gc3RyW2ldLmNoYXJDb2RlQXQoMCkgKiBpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJbaSArIDFdICYmICh0b3RhbCArPSBzdHJbaSArIDFdLmNoYXJDb2RlQXQoMCkgKiAoaSAtIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgTWF0aC5hYnModG90YWwpICUgMjYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICAgICAgICAgIH0oSlNPTi5zdHJpbmdpZnkoe1xuXHQgICAgICAgICAgICAgICAgICAgIHNyYzogc2NyaXB0LnNyYyxcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhc2V0OiBzY3JpcHQuZGF0YXNldFxuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdWlkID0gXCJ1aWRfXCIgKyBoYXNoZWRTdHJpbmcuc2xpY2UoaGFzaGVkU3RyaW5nLmxlbmd0aCAtIDMwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHVpZCA9IHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXVpZC1hdXRvXCIsIHVpZCk7XG5cdCAgICAgICAgICAgIHJldHVybiB1aWQ7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGdsb2JhbF9nZXRHbG9iYWwod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICB2YXIgZ2xvYmFsS2V5ID0gXCJfX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fXCI7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW4gIT09IHdpbmRvdyA/IHdpbltnbG9iYWxLZXldIDogd2luW2dsb2JhbEtleV0gPSB3aW5bZ2xvYmFsS2V5XSB8fCB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGdldE9iaiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBnbG9iYWxTdG9yZShrZXksIGRlZlN0b3JlKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0ga2V5ICYmIChrZXkgPSBcInN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGRlZlN0b3JlICYmIChkZWZTdG9yZSA9IGdldE9iaik7XG5cdCAgICAgICAgICAgIHJldHVybiB1dGlsX2dldE9yU2V0KGdsb2JhbF9nZXRHbG9iYWwoKSwga2V5LCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBkZWZTdG9yZSgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKHN0b3JlS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShzdG9yZUtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHN0b3JlS2V5LCBkZWZWYWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KHN0b3JlS2V5KSA/IHN0b3JlW3N0b3JlS2V5XSA6IGRlZlZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oc3RvcmVLZXksIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVtzdG9yZUtleV0gPSB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKHN0b3JlS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtzdG9yZUtleV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXRPclNldDogZnVuY3Rpb24oc3RvcmVLZXksIGdldHRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF9nZXRPclNldChzdG9yZSwgc3RvcmVLZXksIGdldHRlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlID0gZGVmU3RvcmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIFdpbGRDYXJkID0gZnVuY3Rpb24oKSB7fTtcblx0ICAgICAgICBmdW5jdGlvbiBnZXRXaWxkY2FyZCgpIHtcblx0ICAgICAgICAgICAgdmFyIGdsb2JhbCA9IGdsb2JhbF9nZXRHbG9iYWwoKTtcblx0ICAgICAgICAgICAgZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCA9IGdsb2JhbC5XSU5ET1dfV0lMRENBUkQgfHwgbmV3IFdpbGRDYXJkO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsLldJTkRPV19XSUxEQ0FSRDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gd2luZG93U3RvcmUoa2V5LCBkZWZTdG9yZSkge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGtleSAmJiAoa2V5ID0gXCJzdG9yZVwiKTtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBkZWZTdG9yZSAmJiAoZGVmU3RvcmUgPSBnZXRPYmopO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJ3aW5kb3dTdG9yZVwiKS5nZXRPclNldChrZXksIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5TdG9yZSA9IG5ldyB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ2V0U3RvcmUgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luU3RvcmUuZ2V0T3JTZXQod2luLCBkZWZTdG9yZSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U3RvcmUod2luKS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih3aW4sIGRlZlZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuaGFzT3duUHJvcGVydHkoa2V5KSA/IHN0b3JlW2tleV0gOiBkZWZWYWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHdpbiwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldFN0b3JlKHdpbilba2V5XSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRlbDogZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnZXRTdG9yZSh3aW4pW2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXRPclNldDogZnVuY3Rpb24od2luLCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2V0U3RvcmUod2luKSwga2V5LCBnZXR0ZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0SW5zdGFuY2VJRCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiaW5zdGFuY2VcIikuZ2V0T3JTZXQoXCJpbnN0YW5jZUlEXCIsIHVuaXF1ZUlEKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUhlbGxvUHJvbWlzZSh3aW4sIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWYuZG9tYWluO1xuXHQgICAgICAgICAgICB2YXIgaGVsbG9Qcm9taXNlcyA9IHdpbmRvd1N0b3JlKFwiaGVsbG9Qcm9taXNlc1wiKTtcblx0ICAgICAgICAgICAgdmFyIGV4aXN0aW5nUHJvbWlzZSA9IGhlbGxvUHJvbWlzZXMuZ2V0KHdpbik7XG5cdCAgICAgICAgICAgIGV4aXN0aW5nUHJvbWlzZSAmJiBleGlzdGluZ1Byb21pc2UucmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIG5ld1Byb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBoZWxsb1Byb21pc2VzLnNldCh3aW4sIG5ld1Byb21pc2UpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2F5SGVsbG8od2luLCBfcmVmNCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIF9yZWY0LnNlbmQpKHdpbiwgXCJwb3N0cm9ib3RfaGVsbG9cIiwge1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogZ2V0SW5zdGFuY2VJRCgpXG5cdCAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCIsXG5cdCAgICAgICAgICAgICAgICB0aW1lb3V0OiAtMVxuXHQgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IF9yZWY1Lm9yaWdpbiwgaW5zdGFuY2VJRCA9IF9yZWY1LmRhdGEuaW5zdGFuY2VJRDtcblx0ICAgICAgICAgICAgICAgIHJlc29sdmVIZWxsb1Byb21pc2Uod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW5cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBpbnN0YW5jZUlEXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCBfcmVmNikge1xuXHQgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY2LnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcIndpbmRvd0luc3RhbmNlSURQcm9taXNlc1wiKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzYXlIZWxsbyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy5pbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG1hcmtXaW5kb3dLbm93bih3aW4pIHtcblx0ICAgICAgICAgICAgd2luZG93U3RvcmUoXCJrbm93bldpbmRvd3NcIikuc2V0KHdpbiwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzU2VyaWFsaXplZFR5cGUoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgaXRlbSAmJiBudWxsICE9PSBpdGVtICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0uX190eXBlX187XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRldGVybWluZVR5cGUodmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHZhbCA/IFwidW5kZWZpbmVkXCIgOiBudWxsID09PSB2YWwgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkodmFsKSA/IFwiYXJyYXlcIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJmdW5jdGlvblwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsID8gdmFsIGluc3RhbmNlb2YgRXJyb3IgPyBcImVycm9yXCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbC50aGVuID8gXCJwcm9taXNlXCIgOiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKHZhbCkgPyBcInJlZ2V4XCIgOiBcIltvYmplY3QgRGF0ZV1cIiA9PT0ge30udG9TdHJpbmcuY2FsbCh2YWwpID8gXCJkYXRlXCIgOiBcIm9iamVjdFwiIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsID8gXCJzdHJpbmdcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCA/IFwibnVtYmVyXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdmFsID8gXCJib29sZWFuXCIgOiB2b2lkIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVR5cGUodHlwZSwgdmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBfX3R5cGVfXzogdHlwZSxcblx0ICAgICAgICAgICAgICAgIF9fdmFsX186IHZhbFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgX1NFUklBTElaRVI7XG5cdCAgICAgICAgdmFyIFNFUklBTElaRVIgPSAoKF9TRVJJQUxJWkVSID0ge30pLmZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7fSwgX1NFUklBTElaRVIuZXJyb3IgPSBmdW5jdGlvbihfcmVmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiZXJyb3JcIiwge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZTogX3JlZi5tZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgc3RhY2s6IF9yZWYuc3RhY2ssXG5cdCAgICAgICAgICAgICAgICBjb2RlOiBfcmVmLmNvZGUsXG5cdCAgICAgICAgICAgICAgICBkYXRhOiBfcmVmLmRhdGFcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIucHJvbWlzZSA9IGZ1bmN0aW9uKCkge30sIF9TRVJJQUxJWkVSLnJlZ2V4ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwicmVnZXhcIiwgdmFsLnNvdXJjZSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImRhdGVcIiwgdmFsLnRvSlNPTigpKTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5hcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLmJvb2xlYW4gPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVJbdm9pZCAwXSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcInVuZGVmaW5lZFwiLCB2YWwpO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSKTtcblx0ICAgICAgICB2YXIgZGVmYXVsdFNlcmlhbGl6ZXJzID0ge307XG5cdCAgICAgICAgdmFyIF9ERVNFUklBTElaRVI7XG5cdCAgICAgICAgdmFyIERFU0VSSUFMSVpFUiA9ICgoX0RFU0VSSUFMSVpFUiA9IHt9KS5mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZDsgbm90aGluZyB0byBkZXNlcmlhbGl6ZVwiKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmVycm9yID0gZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gX3JlZjIuc3RhY2ssIGNvZGUgPSBfcmVmMi5jb2RlLCBkYXRhID0gX3JlZjIuZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKF9yZWYyLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcblx0ICAgICAgICAgICAgZGF0YSAmJiAoZXJyb3IuZGF0YSA9IGRhdGEpO1xuXHQgICAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrO1xuXHQgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5wcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21pc2Ugc2VyaWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQ7IG5vdGhpbmcgdG8gZGVzZXJpYWxpemVcIik7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh2YWwpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIubnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUlt2b2lkIDBdID0gZnVuY3Rpb24oKSB7fSwgX0RFU0VSSUFMSVpFUik7XG5cdCAgICAgICAgdmFyIGRlZmF1bHREZXNlcmlhbGl6ZXJzID0ge307XG5cdCAgICAgICAgbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmJvZHkpIHJldHVybiByZXNvbHZlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcblx0ICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSksIDEwKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gY2xlYW51cFByb3h5V2luZG93cygpIHtcblx0ICAgICAgICAgICAgdmFyIGlkVG9Qcm94eVdpbmRvdyA9IGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfaWRUb1Byb3h5V2luZG93JGtleXMyID0gaWRUb1Byb3h5V2luZG93LmtleXMoKTsgX2kyIDwgX2lkVG9Qcm94eVdpbmRvdyRrZXlzMi5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWQgPSBfaWRUb1Byb3h5V2luZG93JGtleXMyW19pMl07XG5cdCAgICAgICAgICAgICAgICBpZFRvUHJveHlXaW5kb3cuZ2V0KGlkKS5zaG91bGRDbGVhbigpICYmIGlkVG9Qcm94eVdpbmRvdy5kZWwoaWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFNlcmlhbGl6ZWRXaW5kb3cod2luUHJvbWlzZSwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYuc2VuZCwgX3JlZiRpZCA9IF9yZWYuaWQsIGlkID0gdm9pZCAwID09PSBfcmVmJGlkID8gdW5pcXVlSUQoKSA6IF9yZWYkaWQ7XG5cdCAgICAgICAgICAgIHZhciB3aW5kb3dOYW1lUHJvbWlzZSA9IHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKHdpbikpIHJldHVybiBhc3NlcnRTYW1lRG9tYWluKHdpbikubmFtZTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB2YXIgd2luZG93VHlwZVByb21pc2UgPSB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbmRvdykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbmRvdykpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBpcyBjbG9zZWQsIGNhbiBub3QgZGV0ZXJtaW5lIHR5cGVcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T3BlbmVyKHdpbmRvdykgPyBcInBvcHVwXCIgOiBcImlmcmFtZVwiO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHdpbmRvd05hbWVQcm9taXNlLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICB3aW5kb3dUeXBlUHJvbWlzZS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgdmFyIGdldE5hbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3dDbG9zZWQod2luKSkgcmV0dXJuIGlzU2FtZURvbWFpbih3aW4pID8gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgOiB3aW5kb3dOYW1lUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dUeXBlUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBnZXRJbnN0YW5jZUlEOiBtZW1vaXplUHJvbWlzZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSksXG5cdCAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbihjbG9zZVdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZ2V0TmFtZTogZ2V0TmFtZSxcblx0ICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luLmZvY3VzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGlzQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93Q2xvc2VkKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHNldExvY2F0aW9uOiBmdW5jdGlvbihocmVmLCBvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBvcHRzICYmIChvcHRzID0ge30pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfb3B0cyRtZXRob2QgPSBvcHRzLm1ldGhvZCwgbWV0aG9kID0gdm9pZCAwID09PSBfb3B0cyRtZXRob2QgPyBcImdldFwiIDogX29wdHMkbWV0aG9kLCBib2R5ID0gb3B0cy5ib2R5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gaHJlZi5pbmRleE9mKFwiL1wiKSkgaHJlZiA9IFwiXCIgKyBkb21haW4gKyBocmVmOyBlbHNlIGlmICghaHJlZi5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSAmJiAwICE9PSBocmVmLmluZGV4T2YoZG9tYWluKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdXJsIHRvIGJlIGh0dHAgb3IgaHR0cHMgdXJsLCBvciBhYnNvbHV0ZSBwYXRoLCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeShocmVmKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInBvc3RcIiA9PT0gbWV0aG9kKSByZXR1cm4gZ2V0TmFtZSgpLnRoZW4oKGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBwb3N0IHRvIHdpbmRvdyB3aXRob3V0IHRhcmdldCBuYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWYzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IF9yZWYzLnVybCwgdGFyZ2V0ID0gX3JlZjMudGFyZ2V0LCBib2R5ID0gX3JlZjMuYm9keSwgX3JlZjMkbWV0aG9kID0gX3JlZjMubWV0aG9kLCBtZXRob2QgPSB2b2lkIDAgPT09IF9yZWYzJG1ldGhvZCA/IFwicG9zdFwiIDogX3JlZjMkbWV0aG9kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcIm1ldGhvZFwiLCBtZXRob2QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwiYWN0aW9uXCIsIHVybCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIGZvciAodmFyIF9pMjQgPSAwLCBfT2JqZWN0JGtleXM0ID0gT2JqZWN0LmtleXMoYm9keSk7IF9pMjQgPCBfT2JqZWN0JGtleXM0Lmxlbmd0aDsgX2kyNCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYm9keSRrZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXM0W19pMjRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwga2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgbnVsbCA9PSAoX2JvZHkka2V5ID0gYm9keVtrZXldKSA/IHZvaWQgMCA6IF9ib2R5JGtleS50b1N0cmluZygpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJvZHkoKS5hcHBlbmRDaGlsZChmb3JtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJvZHkoKS5yZW1vdmVDaGlsZChmb3JtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaHJlZixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZ2V0XCIgIT09IG1ldGhvZCkgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0aG9kOiBcIiArIG1ldGhvZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4od2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4ubG9jYXRpb24gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW4ubG9jYXRpb24ucmVwbGFjZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24gPSBocmVmO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW1lRG9tYWluID0gaXNTYW1lRG9tYWluKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGdldEZyYW1lRm9yV2luZG93KHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2FtZURvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZXQgbmFtZSBmb3IgY3Jvc3MtZG9tYWluIHdpbmRvdzogXCIgKyBuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSAmJiBmcmFtZS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dOYW1lUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUobmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgd2luZG93X1Byb3h5V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIFByb3h5V2luZG93KF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYyLnNlbmQsIHdpbiA9IF9yZWYyLndpbiwgc2VyaWFsaXplZFdpbmRvdyA9IF9yZWYyLnNlcmlhbGl6ZWRXaW5kb3c7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pc1Byb3h5V2luZG93ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93ID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZW5kID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gc2VyaWFsaXplZFdpbmRvdyB8fCBnZXRTZXJpYWxpemVkV2luZG93KHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIikuc2V0KHRoaXMuZ2V0SUQoKSwgdGhpcyk7XG5cdCAgICAgICAgICAgICAgICB3aW4gJiYgdGhpcy5zZXRXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9wcm90byA9IFByb3h5V2luZG93LnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldElEID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlkO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXRUeXBlKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5pc1BvcHVwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkudGhlbigoZnVuY3Rpb24odHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInBvcHVwXCIgPT09IHR5cGU7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uKGhyZWYsIG9wdHMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LnNldExvY2F0aW9uKGhyZWYsIG9wdHMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZ2V0TmFtZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5zZXROYW1lKG5hbWUpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczI7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmNsb3NlKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMztcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmZvY3VzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciBpc1BvcHVwUHJvbWlzZSA9IHRoaXMuaXNQb3B1cCgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGdldE5hbWVQcm9taXNlID0gdGhpcy5nZXROYW1lKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVvcGVuUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuXHQgICAgICAgICAgICAgICAgICAgIGlzUG9wdXA6IGlzUG9wdXBQcm9taXNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldE5hbWVQcm9taXNlXG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICBfcmVmMy5pc1BvcHVwICYmIG5hbWUgJiYgd2luZG93Lm9wZW4oXCJcIiwgbmFtZSwgXCJub29wZW5lclwiKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHZhciBmb2N1c1Byb21pc2UgPSB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZm9jdXMoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyByZW9wZW5Qcm9taXNlLCBmb2N1c1Byb21pc2UgXSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmlzQ2xvc2VkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlzQ2xvc2VkKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvdztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldFdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjQuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93ID0gd2luO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLnJlc29sdmUodGhpcy5hY3R1YWxXaW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gZ2V0U2VyaWFsaXplZFdpbmRvdyh0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kLFxuXHQgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldElEKClcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgd2luZG93U3RvcmUoXCJ3aW5Ub1Byb3h5V2luZG93XCIpLnNldCh3aW4sIHRoaXMpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uYXdhaXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5tYXRjaFdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5hY3R1YWxXaW5kb3cgPyB3aW4gPT09IF90aGlzNS5hY3R1YWxXaW5kb3cgOiBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlJbnN0YW5jZUlEOiBfdGhpczUuZ2V0SW5zdGFuY2VJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrbm93bldpbmRvd0luc3RhbmNlSUQ6IGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gX3JlZjYucHJveHlJbnN0YW5jZUlEID09PSBfcmVmNi5rbm93bldpbmRvd0luc3RhbmNlSUQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoICYmIF90aGlzNS5zZXRXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udW53cmFwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3cgfHwgdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldEluc3RhbmNlSUQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZ2V0SW5zdGFuY2VJRCgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2hvdWxkQ2xlYW4gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuYWN0dWFsV2luZG93ICYmIGlzV2luZG93Q2xvc2VkKHRoaXMuYWN0dWFsV2luZG93KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3c7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LnVud3JhcCA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luKSA/IHdpbi51bndyYXAoKSA6IHdpbjtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cuc2VyaWFsaXplID0gZnVuY3Rpb24od2luLCBfcmVmNykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNy5zZW5kO1xuXHQgICAgICAgICAgICAgICAgY2xlYW51cFByb3h5V2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkuc2VyaWFsaXplKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LmRlc2VyaWFsaXplID0gZnVuY3Rpb24oc2VyaWFsaXplZFdpbmRvdywgX3JlZjgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjguc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKS5nZXQoc2VyaWFsaXplZFdpbmRvdy5pZCkgfHwgbmV3IFByb3h5V2luZG93KHtcblx0ICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkV2luZG93OiBzZXJpYWxpemVkV2luZG93LFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93ID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihvYmogJiYgIWlzV2luZG93KG9iaikgJiYgb2JqLmlzUHJveHlXaW5kb3cpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy50b1Byb3h5V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmOSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmOS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgY2xlYW51cFByb3h5V2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luKSkgcmV0dXJuIHdpbjtcblx0ICAgICAgICAgICAgICAgIHZhciBhY3R1YWxXaW5kb3cgPSB3aW47XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJ3aW5Ub1Byb3h5V2luZG93XCIpLmdldChhY3R1YWxXaW5kb3cpIHx8IG5ldyBQcm94eVdpbmRvdyh7XG5cdCAgICAgICAgICAgICAgICAgICAgd2luOiBhY3R1YWxXaW5kb3csXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdztcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHNvdXJjZSwgZG9tYWluKSB7XG5cdCAgICAgICAgICAgIHZhciBtZXRob2RTdG9yZSA9IHdpbmRvd1N0b3JlKFwibWV0aG9kU3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZhciBwcm94eVdpbmRvd01ldGhvZHMgPSBnbG9iYWxTdG9yZShcInByb3h5V2luZG93TWV0aG9kc1wiKTtcblx0ICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHNvdXJjZSkpIHByb3h5V2luZG93TWV0aG9kcy5zZXQoaWQsIHtcblx0ICAgICAgICAgICAgICAgIHZhbDogdmFsLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Vcblx0ICAgICAgICAgICAgfSk7IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcHJveHlXaW5kb3dNZXRob2RzLmRlbChpZCk7XG5cdCAgICAgICAgICAgICAgICBtZXRob2RTdG9yZS5nZXRPclNldChzb3VyY2UsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSlbaWRdID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWwsXG5cdCAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Vcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbG9va3VwTWV0aG9kKHNvdXJjZSwgaWQpIHtcblx0ICAgICAgICAgICAgdmFyIG1ldGhvZFN0b3JlID0gd2luZG93U3RvcmUoXCJtZXRob2RTdG9yZVwiKTtcblx0ICAgICAgICAgICAgdmFyIHByb3h5V2luZG93TWV0aG9kcyA9IGdsb2JhbFN0b3JlKFwicHJveHlXaW5kb3dNZXRob2RzXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gbWV0aG9kU3RvcmUuZ2V0T3JTZXQoc291cmNlLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgIH0pKVtpZF0gfHwgcHJveHlXaW5kb3dNZXRob2RzLmdldChpZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCBfcmVmMykge1xuXHQgICAgICAgICAgICBvbiA9IChfcmVmID0ge1xuXHQgICAgICAgICAgICAgICAgb246IF9yZWYzLm9uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogX3JlZjMuc2VuZFxuXHQgICAgICAgICAgICB9KS5vbiwgc2VuZCA9IF9yZWYuc2VuZCwgZ2xvYmFsU3RvcmUoXCJidWlsdGluTGlzdGVuZXJzXCIpLmdldE9yU2V0KFwiZnVuY3Rpb25DYWxsc1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb24oXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiXG5cdCAgICAgICAgICAgICAgICB9LCAoZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjIuc291cmNlLCBvcmlnaW4gPSBfcmVmMi5vcmlnaW4sIGRhdGEgPSBfcmVmMi5kYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGRhdGEuaWQsIG5hbWUgPSBkYXRhLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGggPSBsb29rdXBNZXRob2Qoc291cmNlLCBpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRoKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBtZXRob2QgJ1wiICsgbmFtZSArIFwiJyB3aXRoIGlkOiBcIiArIGRhdGEuaWQgKyBcIiBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kU291cmNlID0gbWV0aC5zb3VyY2UsIGRvbWFpbiA9IG1ldGguZG9tYWluLCB2YWwgPSBtZXRoLnZhbDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihkb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCAnXCIgKyBkYXRhLm5hbWUgKyBcIicgZG9tYWluIFwiICsgSlNPTi5zdHJpbmdpZnkodXRpbF9pc1JlZ2V4KG1ldGguZG9tYWluKSA/IG1ldGguZG9tYWluLnNvdXJjZSA6IG1ldGguZG9tYWluKSArIFwiIGRvZXMgbm90IG1hdGNoIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3cobWV0aG9kU291cmNlKSkgcmV0dXJuIG1ldGhvZFNvdXJjZS5tYXRjaFdpbmRvdyhzb3VyY2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24obWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBjYWxsICdcIiArIGRhdGEubmFtZSArIFwiJyBmYWlsZWQgLSBwcm94eSB3aW5kb3cgZG9lcyBub3QgbWF0Y2ggc291cmNlIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmFwcGx5KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGF0YS5hcmdzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwub25FcnJvcikgcmV0dXJuIHZhbC5vbkVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayAmJiAoZXJyLnN0YWNrID0gXCJSZW1vdGUgY2FsbCB0byBcIiArIG5hbWUgKyBcIihcIiArIGZ1bmN0aW9uKGFyZ3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGFyZ3MgJiYgKGFyZ3MgPSBbXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpdGVtID0gYXJncywgW10uc2xpY2UuY2FsbChpdGVtKSkubWFwKChmdW5jdGlvbihhcmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGFyZyA/IFwiJ1wiICsgYXJnICsgXCInXCIgOiB2b2lkIDAgPT09IGFyZyA/IFwidW5kZWZpbmVkXCIgOiBudWxsID09PSBhcmcgPyBcIm51bGxcIiA6IFwiYm9vbGVhblwiID09IHR5cGVvZiBhcmcgPyBhcmcudG9TdHJpbmcoKSA6IEFycmF5LmlzQXJyYXkoYXJnKSA/IFwiWyAuLi4gXVwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgYXJnID8gXCJ7IC4uLiB9XCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFyZyA/IFwiKCkgPT4geyAuLi4gfVwiIDogXCI8XCIgKyB0eXBlb2YgYXJnICsgXCI+XCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmpvaW4oXCIsIFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZGF0YS5hcmdzKSArIFwiKSBmYWlsZWRcXG5cXG5cIiArIGVyci5zdGFjayk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgdmFyIF9yZWYsIG9uLCBzZW5kO1xuXHQgICAgICAgICAgICB2YXIgaWQgPSB2YWwuX19pZF9fIHx8IHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gd2luZG93X1Byb3h5V2luZG93LnVud3JhcChkZXN0aW5hdGlvbik7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gdmFsLl9fbmFtZV9fIHx8IHZhbC5uYW1lIHx8IGtleTtcblx0ICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgbmFtZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG5hbWUuaW5kZXhPZiAmJiAwID09PSBuYW1lLmluZGV4T2YoXCJhbm9ueW1vdXM6OlwiKSAmJiAobmFtZSA9IG5hbWUucmVwbGFjZShcImFub255bW91czo6XCIsIGtleSArIFwiOjpcIikpO1xuXHQgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3coZGVzdGluYXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgZGVzdGluYXRpb24sIGRvbWFpbik7XG5cdCAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCB3aW4sIGRvbWFpbik7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgZGVzdGluYXRpb24sIGRvbWFpbik7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiY3Jvc3NfZG9tYWluX2Z1bmN0aW9uXCIsIHtcblx0ICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBfc2VyaWFsaXplO1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBzZXJpYWxpemVycykge1xuXHQgICAgICAgICAgICAgICAgdm9pZCAwID09PSBzZXJpYWxpemVycyAmJiAoc2VyaWFsaXplcnMgPSBkZWZhdWx0U2VyaWFsaXplcnMpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KG9iaiwgKGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzW2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodGhpcykpIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkZXRlcm1pbmVUeXBlKHZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlKSByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gc2VyaWFsaXplcnNbdHlwZV0gfHwgU0VSSUFMSVpFUlt0eXBlXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplciA/IHNlcmlhbGl6ZXIodmFsLCBrZXkpIDogdmFsO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gcmVzdWx0ID8gXCJ1bmRlZmluZWRcIiA6IHJlc3VsdDtcblx0ICAgICAgICAgICAgfShvYmosICgoX3NlcmlhbGl6ZSA9IHt9KS5wcm9taXNlID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiY3Jvc3NfZG9tYWluX3phbGdvX3Byb21pc2VcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCAoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIGtleSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IF9yZWYub24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBfcmVmLnNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9zZXJpYWxpemUuZnVuY3Rpb24gPSBmdW5jdGlvbih2YWwsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfc2VyaWFsaXplLm9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93KHZhbCkgfHwgd2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3codmFsKSA/IHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5fd2luZG93XCIsIHdpbmRvd19Qcm94eVdpbmRvdy5zZXJpYWxpemUodmFsLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkpIDogdmFsO1xuXHQgICAgICAgICAgICB9LCBfc2VyaWFsaXplKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIF9kZXNlcmlhbGl6ZTtcblx0ICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyLCBkZXNlcmlhbGl6ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGRlc2VyaWFsaXplcnMgJiYgKGRlc2VyaWFsaXplcnMgPSBkZWZhdWx0RGVzZXJpYWxpemVycyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gc3RyKSByZXR1cm4gSlNPTi5wYXJzZShzdHIsIChmdW5jdGlvbihrZXksIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRUeXBlKHRoaXMpKSByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh2YWwpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB2YWwuX190eXBlX187XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsLl9fdmFsX187XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGRldGVybWluZVR5cGUodmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBkZXNlcmlhbGl6ZXJzW3R5cGVdIHx8IERFU0VSSUFMSVpFUlt0eXBlXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVyID8gZGVzZXJpYWxpemVyKHZhbHVlLCBrZXkpIDogdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0obWVzc2FnZSwgKChfZGVzZXJpYWxpemUgPSB7fSkuY3Jvc3NfZG9tYWluX3phbGdvX3Byb21pc2UgPSBmdW5jdGlvbihzZXJpYWxpemVkUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luLCBfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoX3JlZjIudGhlbik7XG5cdCAgICAgICAgICAgICAgICB9KDAsIDAsIHNlcmlhbGl6ZWRQcm9taXNlKTtcblx0ICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplLmNyb3NzX2RvbWFpbl9mdW5jdGlvbiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRGdW5jdGlvbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luLCBfcmVmNCwgX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBfcmVmNC5pZCwgbmFtZSA9IF9yZWY0Lm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKG9wdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBvcHRzICYmIChvcHRzID0ge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHNvdXJjZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGggPSBsb29rdXBNZXRob2Qod2luLCBpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGggJiYgbWV0aC52YWwgIT09IGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyKSByZXR1cm4gbWV0aC52YWwuYXBwbHkoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHdpbmRvdyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4oKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYXJncyA9IFtdLnNsaWNlLmNhbGwoX2FyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuZmlyZUFuZEZvcmdldCA/IHNlbmQod2luLCBcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IF9hcmdzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogdHJ1ZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogc2VuZCh3aW4sIFwicG9zdHJvYm90X21ldGhvZFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogX2FyZ3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiBmYWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGEucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9fbmFtZV9fID0gbmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19vcmlnaW5fXyA9IG9yaWdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19zb3VyY2VfXyA9IHNvdXJjZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19pZF9fID0gaWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLm9yaWdpbiA9IG9yaWdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyID0gZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5maXJlQW5kRm9yZ2V0ID0gZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24oe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiB0cnVlXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyO1xuXHQgICAgICAgICAgICAgICAgfShzb3VyY2UsIG9yaWdpbiwgc2VyaWFsaXplZEZ1bmN0aW9uLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fd2luZG93ID0gZnVuY3Rpb24oc2VyaWFsaXplZFdpbmRvdykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkV2luZG93LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgU0VORF9NRVNTQUdFX1NUUkFURUdJRVMgPSB7fTtcblx0ICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUy5wb3N0cm9ib3RfcG9zdF9tZXNzYWdlID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKSB7XG5cdCAgICAgICAgICAgIDAgPT09IGRvbWFpbi5pbmRleE9mKFwiZmlsZTpcIikgJiYgKGRvbWFpbiA9IFwiKlwiKTtcblx0ICAgICAgICAgICAgd2luLnBvc3RNZXNzYWdlKHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gc2VuZF9zZW5kTWVzc2FnZSh3aW4sIGRvbWFpbiwgbWVzc2FnZSwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZjIub24sIHNlbmQgPSBfcmVmMi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkb21haW5CdWZmZXIgPSB3aW5kb3dTdG9yZSgpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5idWZmZXIgPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmZsdXNoID0gZG9tYWluQnVmZmVyLmZsdXNoIHx8IHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBpcyBjbG9zZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gc2VyaWFsaXplTWVzc2FnZSh3aW4sIGRvbWFpbiwgKChfcmVmID0ge30pLl9fcG9zdF9yb2JvdF8xMF8wXzQ2X18gPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdLCBcblx0ICAgICAgICAgICAgICAgICAgICBfcmVmKSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmJ1ZmZlcjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IE9iamVjdC5rZXlzKFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc3RyYXRlZ2llcy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJhdGVneU5hbWUgPSBzdHJhdGVnaWVzW19pMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFU1tzdHJhdGVneU5hbWVdKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gc3RyYXRlZ2llcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkFsbCBwb3N0LXJvYm90IG1lc3NhZ2luZyBzdHJhdGVnaWVzIGZhaWxlZDpcXG5cXG5cIiArIGVycm9ycy5tYXAoKGZ1bmN0aW9uKGVyciwgaSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIFwiLiBcIiArIHN0cmluZ2lmeUVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLmpvaW4oXCJcXG5cXG5cIikpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkJ1ZmZlci5mbHVzaC50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmZsdXNoO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSkudGhlbihzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UmVzcG9uc2VMaXN0ZW5lcihoYXNoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLmdldChoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihoYXNoKSB7XG5cdCAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuZGVsKGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLmhhcyhoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UmVxdWVzdExpc3RlbmVyKF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsIHdpbiA9IF9yZWYud2luLCBkb21haW4gPSBfcmVmLmRvbWFpbjtcblx0ICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RMaXN0ZW5lcnNcIik7XG5cdCAgICAgICAgICAgIFwiKlwiID09PSB3aW4gJiYgKHdpbiA9IG51bGwpO1xuXHQgICAgICAgICAgICBcIipcIiA9PT0gZG9tYWluICYmIChkb21haW4gPSBudWxsKTtcblx0ICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIHJlcXVpcmVkIHRvIGdldCByZXF1ZXN0IGxpc3RlbmVyXCIpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfcmVmMyA9IFsgd2luLCBnZXRXaWxkY2FyZCgpIF07IF9pNCA8IF9yZWYzLmxlbmd0aDsgX2k0KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5RdWFsaWZpZXIgPSBfcmVmM1tfaTRdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpblF1YWxpZmllcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVycy5nZXQod2luUXVhbGlmaWVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobmFtZUxpc3RlbmVycykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluTGlzdGVuZXJzID0gbmFtZUxpc3RlbmVyc1tuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVycykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzW2RvbWFpbl0pIHJldHVybiBkb21haW5MaXN0ZW5lcnNbZG9tYWluXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X18pIGZvciAodmFyIF9pNiA9IDAsIF9kb21haW5MaXN0ZW5lcnMkX19ETzIgPSBkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXzsgX2k2IDwgX2RvbWFpbkxpc3RlbmVycyRfX0RPMi5sZW5ndGg7IF9pNisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZG9tYWluTGlzdGVuZXJzJF9fRE8zID0gX2RvbWFpbkxpc3RlbmVycyRfX0RPMltfaTZdLCBsaXN0ZW5lciA9IF9kb21haW5MaXN0ZW5lcnMkX19ETzMubGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaERvbWFpbihfZG9tYWluTGlzdGVuZXJzJF9fRE8zLnJlZ2V4LCBkb21haW4pKSByZXR1cm4gbGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVyc1tcIipcIl0pIHJldHVybiBkb21haW5MaXN0ZW5lcnNbXCIqXCJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3Qoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLFxuXHQgICAgICAgICAgICAgICAgd2luOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIGxvZ05hbWUgPSBcInBvc3Ryb2JvdF9tZXRob2RcIiA9PT0gbWVzc2FnZS5uYW1lICYmIG1lc3NhZ2UuZGF0YSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBtZXNzYWdlLmRhdGEubmFtZSA/IG1lc3NhZ2UuZGF0YS5uYW1lICsgXCIoKVwiIDogbWVzc2FnZS5uYW1lO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZW5kUmVzcG9uc2UoYWNrLCBkYXRhLCBlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmZpcmVBbmRGb3JnZXQgJiYgIWlzV2luZG93Q2xvc2VkKHNvdXJjZSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3Jlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBtZXNzYWdlLmhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2s6IGFjayxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCByZXNwb25zZSBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCAmJiAhaXNXaW5kb3dDbG9zZWQoc291cmNlKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0cm9ib3RfbWVzc2FnZV9hY2tcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWVcblx0ICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCBhY2sgbWVzc2FnZSBmYWlsZWQgZm9yIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIlxcblxcblwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pKSwgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmhhbmRsZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKFwic3VjY2Vzc1wiLCBkYXRhKTtcblx0ICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcImVycm9yXCIsIG51bGwsIGVycm9yKTtcblx0ICAgICAgICAgICAgfSkpIF0pLnRoZW4oc3JjX3V0aWxfbm9vcCkuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVFcnJvcikgcmV0dXJuIG9wdGlvbnMuaGFuZGxlRXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVBY2soc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKG1lc3NhZ2UuaGFzaCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0UmVzcG9uc2VMaXN0ZW5lcihtZXNzYWdlLmhhc2gpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgYWNrIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQWNrIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArIG9wdGlvbnMuZG9tYWluLnRvU3RyaW5nKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IG9wdGlvbnMud2luKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgc291cmNlIGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgd2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5hY2sgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldFJlc3BvbnNlTGlzdGVuZXIobWVzc2FnZS5oYXNoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlIHJlc3BvbnNlIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4ob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArIChwYXR0ZXJuID0gb3B0aW9ucy5kb21haW4sIFxuXHQgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwYXR0ZXJuKSA/IFwiKFwiICsgcGF0dGVybi5qb2luKFwiIHwgXCIpICsgXCIpXCIgOiBpc1JlZ2V4KHBhdHRlcm4pID8gXCJSZWdFeHAoXCIgKyBwYXR0ZXJuLnRvU3RyaW5nKCkgKyBcIilcIiA6IHBhdHRlcm4udG9TdHJpbmcoKSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm47XG5cdCAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBvcHRpb25zLndpbikgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugc291cmNlIGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgd2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihtZXNzYWdlLmhhc2gpO1xuXHQgICAgICAgICAgICAgICAgXCJlcnJvclwiID09PSBtZXNzYWdlLmFjayA/IG9wdGlvbnMucHJvbWlzZS5yZWplY3QobWVzc2FnZS5lcnJvcikgOiBcInN1Y2Nlc3NcIiA9PT0gbWVzc2FnZS5hY2sgJiYgb3B0aW9ucy5wcm9taXNlLnJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZV9yZWNlaXZlTWVzc2FnZShldmVudCwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZjIub24sIHNlbmQgPSBfcmVmMi5zZW5kO1xuXHQgICAgICAgICAgICB2YXIgcmVjZWl2ZWRNZXNzYWdlcyA9IGdsb2JhbFN0b3JlKFwicmVjZWl2ZWRNZXNzYWdlc1wiKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghd2luZG93IHx8IHdpbmRvdy5jbG9zZWQgfHwgIWV2ZW50LnNvdXJjZSkgcmV0dXJuO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlLCBvcmlnaW4gPSBldmVudC5vcmlnaW47XG5cdCAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHNvdXJjZSwgb3JpZ2luLCBfcmVmKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcnNlZE1lc3NhZ2U7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcnNlZE1lc3NhZ2UgPSBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBwYXJzZWRNZXNzYWdlICYmIG51bGwgIT09IHBhcnNlZE1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VNZXNzYWdlcyA9IHBhcnNlZE1lc3NhZ2UuX19wb3N0X3JvYm90XzEwXzBfNDZfXztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZU1lc3NhZ2VzKSkgcmV0dXJuIHBhcnNlTWVzc2FnZXM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0oZXZlbnQuZGF0YSwgc291cmNlLCBvcmlnaW4sIHtcblx0ICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlcykge1xuXHQgICAgICAgICAgICAgICAgbWFya1dpbmRvd0tub3duKHNvdXJjZSk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBtZXNzYWdlcy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlc1tfaTJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlLmlkKSkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZXMuc2V0KG1lc3NhZ2UuaWQsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZChzb3VyY2UpICYmICFtZXNzYWdlLmZpcmVBbmRGb3JnZXQpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAwID09PSBtZXNzYWdlLm9yaWdpbi5pbmRleE9mKFwiZmlsZTpcIikgJiYgKG9yaWdpbiA9IFwiZmlsZTovL1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVxdWVzdChzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVzcG9uc2VcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIDogXCJwb3N0cm9ib3RfbWVzc2FnZV9hY2tcIiA9PT0gbWVzc2FnZS50eXBlICYmIGhhbmRsZUFjayhzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uX29uKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBuYW1lXCIpO1xuXHQgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pKSB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRSZXF1ZXN0TGlzdGVuZXIoX3JlZjQsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWY0Lm5hbWUsIHdpbkNhbmRpZGF0ZSA9IF9yZWY0LndpbiwgZG9tYWluID0gX3JlZjQuZG9tYWluO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RMaXN0ZW5lcnNcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5hbWUgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSByZXF1aXJlZCB0byBhZGQgcmVxdWVzdCBsaXN0ZW5lclwiKTtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5DYW5kaWRhdGUgJiYgXCIqXCIgIT09IHdpbkNhbmRpZGF0ZSAmJiB3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh3aW5DYW5kaWRhdGUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lclByb21pc2UgPSB3aW5DYW5kaWRhdGUuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbihhY3R1YWxXaW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luOiBhY3R1YWxXaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdGVuZXJQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcXVlc3RMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0TGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIHdpbiA9IHdpbkNhbmRpZGF0ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdpbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pOCA9IDAsIF93aW4yID0gd2luOyBfaTggPCBfd2luMi5sZW5ndGg7IF9pOCsrKSBsaXN0ZW5lcnNDb2xsZWN0aW9uLnB1c2goYWRkUmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogX3dpbjJbX2k4XVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgbGlzdGVuZXJzQ29sbGVjdGlvbi5sZW5ndGg7IF9pMTArKykgbGlzdGVuZXJzQ29sbGVjdGlvbltfaTEwXS5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW4pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9saXN0ZW5lcnNDb2xsZWN0aW9uID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMiA9IDAsIF9kb21haW4yID0gZG9tYWluOyBfaTEyIDwgX2RvbWFpbjIubGVuZ3RoOyBfaTEyKyspIF9saXN0ZW5lcnNDb2xsZWN0aW9uLnB1c2goYWRkUmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX2RvbWFpbjJbX2kxMl1cblx0ICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcikpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IF9saXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxNCsrKSBfbGlzdGVuZXJzQ29sbGVjdGlvbltfaTE0XS5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdMaXN0ZW5lciA9IGdldFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB3aW4gJiYgXCIqXCIgIT09IHdpbiB8fCAod2luID0gZ2V0V2lsZGNhcmQoKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RyRG9tYWluID0gKGRvbWFpbiA9IGRvbWFpbiB8fCBcIipcIikudG9TdHJpbmcoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0xpc3RlbmVyKSB0aHJvdyB3aW4gJiYgZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiB3aW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiBkb21haW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBvbiBkb21haW4gXCIgKyBkb21haW4udG9TdHJpbmcoKSkgOiBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVMaXN0ZW5lcnMgPSByZXF1ZXN0TGlzdGVuZXJzLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lRG9tYWluTGlzdGVuZXJzID0gdXRpbF9nZXRPclNldCh3aW5OYW1lTGlzdGVuZXJzLCBuYW1lLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycztcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgIHV0aWxfaXNSZWdleChkb21haW4pID8gKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycyA9IHV0aWxfZ2V0T3JTZXQod2luTmFtZURvbWFpbkxpc3RlbmVycywgXCJfX2RvbWFpbl9yZWdleF9fXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgICAgICAgICB9KSkpLnB1c2god2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXg6IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcblx0ICAgICAgICAgICAgICAgIH0pIDogd2luTmFtZURvbWFpbkxpc3RlbmVyc1tzdHJEb21haW5dID0gbGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5OYW1lRG9tYWluTGlzdGVuZXJzW3N0ckRvbWFpbl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzLnNwbGljZSh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMuaW5kZXhPZih3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lciwgMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzLmxlbmd0aCB8fCBkZWxldGUgd2luTmFtZURvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHdpbk5hbWVEb21haW5MaXN0ZW5lcnMpLmxlbmd0aCB8fCBkZWxldGUgd2luTmFtZUxpc3RlbmVyc1tuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luICYmICFPYmplY3Qua2V5cyh3aW5OYW1lTGlzdGVuZXJzKS5sZW5ndGggJiYgcmVxdWVzdExpc3RlbmVycy5kZWwod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICB3aW46IG9wdGlvbnMud2luZG93LFxuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBvcHRpb25zLmRvbWFpbiB8fCBcIipcIlxuXHQgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyIHx8IG9wdGlvbnMuaGFuZGxlcixcblx0ICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yOiBvcHRpb25zLmVycm9ySGFuZGxlciB8fCBmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uX29uY2UobmFtZSwgb3B0aW9ucywgaGFuZGxlcikge1xuXHQgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pKSB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICBvcHRpb25zLmVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBsaXN0ZW5lciA9IG9uX29uKG5hbWUsIG9wdGlvbnMsIChmdW5jdGlvbihldmVudCkge1xuXHQgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHJldHVybiBoYW5kbGVyKGV2ZW50KTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCA9IGxpc3RlbmVyLmNhbmNlbDtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzZW5kX3NlbmQgPSBmdW5jdGlvbiBzZW5kKHdpbk9yUHJveHlXaW4sIG5hbWUsIGRhdGEsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIGRvbWFpbk1hdGNoZXIgPSAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLmRvbWFpbiB8fCBcIipcIjtcblx0ICAgICAgICAgICAgdmFyIHJlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCAtMTtcblx0ICAgICAgICAgICAgdmFyIGNoaWxkVGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCA1ZTM7XG5cdCAgICAgICAgICAgIHZhciBmaXJlQW5kRm9yZ2V0ID0gb3B0aW9ucy5maXJlQW5kRm9yZ2V0IHx8IGZhbHNlO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luT3JQcm94eVdpbiwge1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICB9KS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKG5hbWUsIHdpbiwgZG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGRvbWFpbiAmJiAhQXJyYXkuaXNBcnJheShkb21haW4pICYmICF1dGlsX2lzUmVnZXgoZG9tYWluKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3Qgc2VuZCBcIiArIG5hbWUgKyBcIi4gRXhwZWN0ZWQgZG9tYWluIFwiICsgSlNPTi5zdHJpbmdpZnkoZG9tYWluKSArIFwiIHRvIGJlIGEgc3RyaW5nLCBhcnJheSwgb3IgcmVnZXhcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNlbmQgXCIgKyBuYW1lICsgXCIuIFRhcmdldCB3aW5kb3cgaXMgY2xvc2VkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0obmFtZSwgd2luLCBkb21haW5NYXRjaGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0dWFsUGFyZW50ID0gZ2V0QW5jZXN0b3IoY2hpbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsUGFyZW50KSByZXR1cm4gYWN0dWFsUGFyZW50ID09PSBwYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luLnRvcCkgcmV0dXJuIHdpbi50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KHdpbikgPT09IHdpbikgcmV0dXJuIHdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luZG93LCB3aW4pICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbmNlc3RvclBhcmVudCh3aW4sIHdpbmRvdykgJiYgd2luZG93LnRvcCkgcmV0dXJuIHdpbmRvdy50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTcgPSAwLCBfZ2V0QWxsQ2hpbGRGcmFtZXM0ID0gZnVuY3Rpb24gZ2V0QWxsQ2hpbGRGcmFtZXMod2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9nZXRGcmFtZXMyID0gZ2V0RnJhbWVzKHdpbik7IF9pMyA8IF9nZXRGcmFtZXMyLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2dldEZyYW1lczJbX2kzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwLCBfZ2V0QWxsQ2hpbGRGcmFtZXMyID0gZ2V0QWxsQ2hpbGRGcmFtZXMoZnJhbWUpOyBfaTUgPCBfZ2V0QWxsQ2hpbGRGcmFtZXMyLmxlbmd0aDsgX2k1KyspIHJlc3VsdC5wdXNoKF9nZXRBbGxDaGlsZEZyYW1lczJbX2k1XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7IF9pNyA8IF9nZXRBbGxDaGlsZEZyYW1lczQubGVuZ3RoOyBfaTcrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9nZXRBbGxDaGlsZEZyYW1lczRbX2k3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUudG9wKSByZXR1cm4gZnJhbWUudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KGZyYW1lKSA9PT0gZnJhbWUpIHJldHVybiBmcmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfShjaGlsZCkgPT09IGNoaWxkKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTUgPSAwLCBfZ2V0RnJhbWVzOCA9IGdldEZyYW1lcyhwYXJlbnQpOyBfaTE1IDwgX2dldEZyYW1lczgubGVuZ3RoOyBfaTE1KyspIGlmIChfZ2V0RnJhbWVzOFtfaTE1XSA9PT0gY2hpbGQpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW5kb3csIHdpbikpIHJldHVybiBmdW5jdGlvbih3aW4sIHRpbWVvdXQsIG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB0aW1lb3V0ICYmICh0aW1lb3V0ID0gNWUzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuYW1lICYmIChuYW1lID0gXCJXaW5kb3dcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJoZWxsb1Byb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IHRpbWVvdXQgJiYgKHByb21pc2UgPSBwcm9taXNlLnRpbWVvdXQodGltZW91dCwgbmV3IEVycm9yKG5hbWUgKyBcIiBkaWQgbm90IGxvYWQgYWZ0ZXIgXCIgKyB0aW1lb3V0ICsgXCJtc1wiKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbiwgY2hpbGRUaW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihfdGVtcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih3aW4sIHRhcmdldERvbWFpbiwgYWN0dWFsRG9tYWluLCBfcmVmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0YXJnZXREb21haW4gPyB0YXJnZXREb21haW4gOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxEb21haW4gfHwgc2F5SGVsbG8od2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuZG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihub3JtYWxpemVkRG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbih0YXJnZXREb21haW4sIHRhcmdldERvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkRvbWFpbiBcIiArIHN0cmluZ2lmeSh0YXJnZXREb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggXCIgKyBzdHJpbmdpZnkodGFyZ2V0RG9tYWluKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWREb21haW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbiwgZG9tYWluTWF0Y2hlciwgKHZvaWQgMCA9PT0gX3RlbXAgPyB7fSA6IF90ZW1wKS5kb21haW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHRhcmdldERvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0YXJnZXREb21haW47XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ05hbWUgPSBcInBvc3Ryb2JvdF9tZXRob2RcIiA9PT0gbmFtZSAmJiBkYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGRhdGEubmFtZSA/IGRhdGEubmFtZSArIFwiKClcIiA6IG5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBuYW1lICsgXCJfXCIgKyB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZmlyZUFuZEZvcmdldCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VMaXN0ZW5lciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCwgbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuc2V0KGhhc2gsIGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfShoYXNoLCByZXNwb25zZUxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVByb21pc2VzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMucHVzaChwcm9taXNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYXRjaCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLnNldChoYXNoLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oaGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZXNwb25zZUxpc3RlbmVyKGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbEFja1RpbWVvdXQgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcImtub3duV2luZG93c1wiKS5nZXQod2luLCBmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKSA/IDFlNCA6IDJlMztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsUmVzVGltZW91dCA9IHJlc3BvbnNlVGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFja1RpbWVvdXQgPSB0b3RhbEFja1RpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNUaW1lb3V0ID0gdG90YWxSZXNUaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBmdW5jdGlvbihtZXRob2QsIHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uIGxvb3AoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBjbG9zZWQgZm9yIFwiICsgbmFtZSArIFwiIGJlZm9yZSBcIiArIChyZXNwb25zZUxpc3RlbmVyLmFjayA/IFwicmVzcG9uc2VcIiA6IFwiYWNrXCIpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VMaXN0ZW5lci5jYW5jZWxsZWQpIHJldHVybiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXNwb25zZSBsaXN0ZW5lciB3YXMgY2FuY2VsbGVkIGZvciBcIiArIG5hbWUpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFja1RpbWVvdXQgPSBNYXRoLm1heChhY2tUaW1lb3V0IC0gNTAwLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSByZXNUaW1lb3V0ICYmIChyZXNUaW1lb3V0ID0gTWF0aC5tYXgocmVzVGltZW91dCAtIDUwMCwgMCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VMaXN0ZW5lci5hY2sgfHwgMCAhPT0gYWNrVGltZW91dCA/IDAgPT09IHJlc1RpbWVvdXQgJiYgcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gcmVzcG9uc2UgZm9yIHBvc3RNZXNzYWdlIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIiBpbiBcIiArIHRvdGFsUmVzVGltZW91dCArIFwibXNcIikpIDogcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gYWNrIGZvciBwb3N0TWVzc2FnZSBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCIgaW4gXCIgKyB0b3RhbEFja1RpbWVvdXQgKyBcIm1zXCIpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDUwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmluYWxseSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcVByb21pc2VzLnNwbGljZShyZXFQcm9taXNlcy5pbmRleE9mKHByb21pc2UsIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kTWVzc2FnZSh3aW4sIGRvbWFpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6IGZpcmVBbmRGb3JnZXRcblx0ICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyZUFuZEZvcmdldCA/IHByb21pc2UucmVzb2x2ZSgpIDogcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIHJlcXVlc3QgbWVzc2FnZSBmYWlsZWQgZm9yIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIlxcblxcblwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cF9zZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaikge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmosIHtcblx0ICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXBfZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJveHlXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93X1Byb3h5V2luZG93KHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZCxcblx0ICAgICAgICAgICAgICAgIHdpbjogd2luXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cF90b1Byb3h5V2luZG93KHdpbikge1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuXHQgICAgICAgICAgICBpZiAoIWdsb2JhbF9nZXRHbG9iYWwoKS5pbml0aWFsaXplZCkge1xuXHQgICAgICAgICAgICAgICAgZ2xvYmFsX2dldEdsb2JhbCgpLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIG9uID0gKF9yZWYzID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pLm9uLCBzZW5kID0gX3JlZjMuc2VuZCwgKGdsb2JhbCA9IGdsb2JhbF9nZXRHbG9iYWwoKSkucmVjZWl2ZU1lc3NhZ2UgPSBnbG9iYWwucmVjZWl2ZU1lc3NhZ2UgfHwgZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjUub24sIHNlbmQgPSBfcmVmNS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKCkuZ2V0T3JTZXQoXCJwb3N0TWVzc2FnZUxpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgZXZlbnQsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0od2luZG93LCAwLCAoZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihldmVudCwgX3JlZjQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmNC5vbiwgc2VuZCA9IF9yZWY0LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5zb3VyY2VFbGVtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZXZlbnQub3JpZ2luIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5vcmlnaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJudWxsXCIgPT09IG9yaWdpbiAmJiAob3JpZ2luID0gXCJmaWxlOi8vXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbikgdGhyb3cgbmV3IEVycm9yKFwiUG9zdCBtZXNzYWdlIGRpZCBub3QgaGF2ZSBvcmlnaW4gZG9tYWluXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZV9yZWNlaXZlTWVzc2FnZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZXZlbnQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWY4Lm9uLCBzZW5kID0gX3JlZjguc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImJ1aWx0aW5MaXN0ZW5lcnNcIikuZ2V0T3JTZXQoXCJoZWxsb0xpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gb24oXCJwb3N0cm9ib3RfaGVsbG9cIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCAoZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVIZWxsb1Byb21pc2UoX3JlZjMuc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfcmVmMy5vcmlnaW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldEFuY2VzdG9yKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiBzYXlIZWxsbyhwYXJlbnQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGZ1bmN0aW9uKGVycikge30pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcmVmMywgb24sIHNlbmQsIGdsb2JhbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXJzID0gZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9yZXNwb25zZUxpc3RlbmVycyRrZTIgPSByZXNwb25zZUxpc3RlbmVycy5rZXlzKCk7IF9pMiA8IF9yZXNwb25zZUxpc3RlbmVycyRrZTIubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMltfaTJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHJlc3BvbnNlTGlzdGVuZXJzLmdldChoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciAmJiAobGlzdGVuZXIuY2FuY2VsbGVkID0gdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VMaXN0ZW5lcnMuZGVsKGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgIChsaXN0ZW5lciA9IGdsb2JhbFN0b3JlKCkuZ2V0KFwicG9zdE1lc3NhZ2VMaXN0ZW5lclwiKSkgJiYgbGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgIHZhciBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5fX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3JjX3R5cGVzX1RZUEVTXzAgPSB0cnVlO1xuXHQgICAgICAgIGZ1bmN0aW9uIGNsZWFuVXBXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9yZXF1ZXN0UHJvbWlzZXMkZ2V0MiA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdFByb21pc2VzXCIpLmdldCh3aW4sIFtdKTsgX2kyIDwgX3JlcXVlc3RQcm9taXNlcyRnZXQyLmxlbmd0aDsgX2kyKyspIF9yZXF1ZXN0UHJvbWlzZXMkZ2V0MltfaTJdLnJlamVjdChuZXcgRXJyb3IoXCJXaW5kb3cgXCIgKyAoaXNXaW5kb3dDbG9zZWQod2luKSA/IFwiY2xvc2VkXCIgOiBcImNsZWFuZWQgdXBcIikgKyBcIiBiZWZvcmUgcmVzcG9uc2VcIikpLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzZXR1cCgpO1xuXHQgICAgfSBdKTtcblx0fSkpOyBcbn0gKHBvc3RSb2JvdCkpO1xuXG52YXIgcG9zdFJvYm90RXhwb3J0cyQxID0gcG9zdFJvYm90LmV4cG9ydHM7XG5cbi8qIEBmbG93ICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cdC8vICRGbG93Rml4TWVcblx0bW9kdWxlLmV4cG9ydHMgPSBwb3N0Um9ib3RFeHBvcnRzJDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWNvbW1vbmpzXG5cblx0Ly8gJEZsb3dGaXhNZVxuXHRtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWNvbW1vbmpzIFxufSAocG9zdFJvYm90JDEpKTtcblxudmFyIHBvc3RSb2JvdEV4cG9ydHMgPSBwb3N0Um9ib3QkMS5leHBvcnRzO1xudmFyIGluZGV4ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHBvc3RSb2JvdEV4cG9ydHMpO1xuXG52YXIgaW5kZXgkMSA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0OiBpbmRleFxufSwgW3Bvc3RSb2JvdEV4cG9ydHNdKTtcblxuZXhwb3J0IHsgaW5kZXgkMSBhcyBpIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/family/lib/index-Cs-onntv.js\n"));

/***/ })

}]);